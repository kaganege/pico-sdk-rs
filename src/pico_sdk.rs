/* automatically generated by rust-bindgen 0.69.4 */

#![allow(non_upper_case_globals, non_camel_case_types, non_snake_case)]

#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6] = b"4.4.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 4;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __RAND_MAX: u32 = 2147483647;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const M_MXFAST: u32 = 1;
pub const M_NLBLKS: u32 = 2;
pub const M_GRAIN: u32 = 3;
pub const M_KEEP: u32 = 4;
pub const M_TRIM_THRESHOLD: i32 = -1;
pub const M_TOP_PAD: i32 = -2;
pub const M_MMAP_THRESHOLD: i32 = -3;
pub const M_MMAP_MAX: i32 = -4;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const PARAM_ASSERTIONS_ENABLE_ALL: u32 = 0;
pub const PARAM_ASSERTIONS_DISABLE_ALL: u32 = 0;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const PICO_SDK_VERSION_MAJOR: u32 = 1;
pub const PICO_SDK_VERSION_MINOR: u32 = 5;
pub const PICO_SDK_VERSION_REVISION: u32 = 1;
pub const PICO_SDK_VERSION_STRING: &[u8; 6] = b"1.5.1\0";
pub const PICO_DEFAULT_UART: u32 = 0;
pub const PICO_DEFAULT_UART_TX_PIN: u32 = 0;
pub const PICO_DEFAULT_UART_RX_PIN: u32 = 1;
pub const PICO_DEFAULT_LED_PIN: u32 = 25;
pub const PICO_DEFAULT_I2C: u32 = 0;
pub const PICO_DEFAULT_I2C_SDA_PIN: u32 = 4;
pub const PICO_DEFAULT_I2C_SCL_PIN: u32 = 5;
pub const PICO_DEFAULT_SPI: u32 = 0;
pub const PICO_DEFAULT_SPI_SCK_PIN: u32 = 18;
pub const PICO_DEFAULT_SPI_TX_PIN: u32 = 19;
pub const PICO_DEFAULT_SPI_RX_PIN: u32 = 16;
pub const PICO_DEFAULT_SPI_CSN_PIN: u32 = 17;
pub const PICO_BOOT_STAGE2_CHOOSE_W25Q080: u32 = 1;
pub const PICO_FLASH_SPI_CLKDIV: u32 = 2;
pub const PICO_FLASH_SIZE_BYTES: u32 = 2097152;
pub const PICO_SMPS_MODE_PIN: u32 = 23;
pub const PICO_RP2040_B0_SUPPORTED: u32 = 1;
pub const PICO_VBUS_PIN: u32 = 24;
pub const PICO_VSYS_PIN: u32 = 29;
pub const VTABLE_FIRST_IRQ: u32 = 16;
pub const REG_ALIAS_RW_BITS: u32 = 0;
pub const REG_ALIAS_XOR_BITS: u32 = 4096;
pub const REG_ALIAS_SET_BITS: u32 = 8192;
pub const REG_ALIAS_CLR_BITS: u32 = 12288;
pub const SIO_CPUID_RESET: &[u8; 2] = b"-\0";
pub const SIO_CPUID_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_GPIO_IN_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_GPIO_HI_IN_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_GPIO_OUT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_GPIO_OUT_SET_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_GPIO_OUT_CLR_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_GPIO_OUT_XOR_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_GPIO_OE_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_GPIO_OE_SET_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_GPIO_OE_CLR_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_GPIO_OE_XOR_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_GPIO_HI_OUT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_GPIO_HI_OUT_SET_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_GPIO_HI_OUT_CLR_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_GPIO_HI_OUT_XOR_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_GPIO_HI_OE_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_GPIO_HI_OE_SET_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_GPIO_HI_OE_CLR_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_GPIO_HI_OE_XOR_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_FIFO_ST_ROE_ACCESS: &[u8; 3] = b"WC\0";
pub const SIO_FIFO_ST_WOF_ACCESS: &[u8; 3] = b"WC\0";
pub const SIO_FIFO_ST_RDY_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_FIFO_ST_VLD_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_FIFO_WR_ACCESS: &[u8; 3] = b"WF\0";
pub const SIO_FIFO_RD_RESET: &[u8; 2] = b"-\0";
pub const SIO_FIFO_RD_ACCESS: &[u8; 3] = b"RF\0";
pub const SIO_SPINLOCK_ST_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_DIV_UDIVIDEND_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_DIV_UDIVISOR_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_DIV_SDIVIDEND_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_DIV_SDIVISOR_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_DIV_QUOTIENT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_DIV_REMAINDER_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_DIV_CSR_DIRTY_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_DIV_CSR_READY_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP0_ACCUM0_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_ACCUM1_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_BASE0_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_BASE1_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_BASE2_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_POP_LANE0_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP0_POP_LANE1_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP0_POP_FULL_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP0_PEEK_LANE0_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP0_PEEK_LANE1_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP0_PEEK_FULL_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP0_CTRL_LANE0_OVERF_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP0_CTRL_LANE0_OVERF1_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP0_CTRL_LANE0_OVERF0_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP0_CTRL_LANE0_BLEND_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_FORCE_MSB_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_ADD_RAW_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_CROSS_RESULT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_CROSS_INPUT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_SIGNED_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_MASK_MSB_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_MASK_LSB_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_SHIFT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_FORCE_MSB_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_ADD_RAW_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_CROSS_RESULT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_CROSS_INPUT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_SIGNED_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_MASK_MSB_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_MASK_LSB_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_SHIFT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_ACCUM0_ADD_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_ACCUM1_ADD_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP0_BASE_1AND0_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_INTERP1_ACCUM0_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_ACCUM1_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_BASE0_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_BASE1_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_BASE2_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_POP_LANE0_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP1_POP_LANE1_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP1_POP_FULL_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP1_PEEK_LANE0_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP1_PEEK_LANE1_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP1_PEEK_FULL_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP1_CTRL_LANE0_OVERF_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP1_CTRL_LANE0_OVERF1_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP1_CTRL_LANE0_OVERF0_ACCESS: &[u8; 3] = b"RO\0";
pub const SIO_INTERP1_CTRL_LANE0_CLAMP_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_FORCE_MSB_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_ADD_RAW_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_CROSS_RESULT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_CROSS_INPUT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_SIGNED_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_MASK_MSB_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_MASK_LSB_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_SHIFT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_FORCE_MSB_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_ADD_RAW_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_CROSS_RESULT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_CROSS_INPUT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_SIGNED_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_MASK_MSB_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_MASK_LSB_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_SHIFT_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_ACCUM0_ADD_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_ACCUM1_ADD_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_INTERP1_BASE_1AND0_ACCESS: &[u8; 3] = b"WO\0";
pub const SIO_SPINLOCK0_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK1_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK2_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK3_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK4_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK5_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK6_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK7_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK8_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK9_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK10_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK11_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK12_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK13_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK14_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK15_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK16_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK17_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK18_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK19_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK20_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK21_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK22_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK23_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK24_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK25_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK26_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK27_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK28_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK29_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK30_ACCESS: &[u8; 3] = b"RW\0";
pub const SIO_SPINLOCK31_ACCESS: &[u8; 3] = b"RW\0";
pub const PICO_RP2040: u32 = 1;
pub const PICO_NO_RAM_VECTOR_TABLE: u32 = 0;
pub const PICO_FLOAT_SUPPORT_ROM_V1: u32 = 1;
pub const PICO_DOUBLE_SUPPORT_ROM_V1: u32 = 1;
pub const PICO_RP2040_B1_SUPPORTED: u32 = 1;
pub const PICO_RP2040_B2_SUPPORTED: u32 = 1;
pub const PICO_C_COMPILER_IS_CLANG: u32 = 1;
pub const PICO_NO_FPGA_CHECK: u32 = 0;
pub const PICO_STDOUT_MUTEX: u32 = 1;
pub const PICO_STDIO_ENABLE_CRLF_SUPPORT: u32 = 1;
pub const PICO_STDIO_DEFAULT_CRLF: u32 = 1;
pub const PICO_STDIO_STACK_BUFFER_SIZE: u32 = 128;
pub const PICO_STDIO_DEADLOCK_TIMEOUT_MS: u32 = 1000;
pub const PARAM_ASSERTIONS_ENABLED_ADDRESS_ALIAS: u32 = 0;
pub const TIMER_TIMEHW_ACCESS: &[u8; 3] = b"WF\0";
pub const TIMER_TIMELW_ACCESS: &[u8; 3] = b"WF\0";
pub const TIMER_TIMEHR_ACCESS: &[u8; 3] = b"RO\0";
pub const TIMER_TIMELR_ACCESS: &[u8; 3] = b"RO\0";
pub const TIMER_ALARM0_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_ALARM1_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_ALARM2_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_ALARM3_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_ARMED_ACCESS: &[u8; 3] = b"WC\0";
pub const TIMER_TIMERAWH_ACCESS: &[u8; 3] = b"RO\0";
pub const TIMER_TIMERAWL_ACCESS: &[u8; 3] = b"RO\0";
pub const TIMER_DBGPAUSE_DBG1_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_DBGPAUSE_DBG0_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_PAUSE_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_INTR_ALARM_3_ACCESS: &[u8; 3] = b"WC\0";
pub const TIMER_INTR_ALARM_2_ACCESS: &[u8; 3] = b"WC\0";
pub const TIMER_INTR_ALARM_1_ACCESS: &[u8; 3] = b"WC\0";
pub const TIMER_INTR_ALARM_0_ACCESS: &[u8; 3] = b"WC\0";
pub const TIMER_INTE_ALARM_3_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_INTE_ALARM_2_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_INTE_ALARM_1_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_INTE_ALARM_0_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_INTF_ALARM_3_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_INTF_ALARM_2_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_INTF_ALARM_1_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_INTF_ALARM_0_ACCESS: &[u8; 3] = b"RW\0";
pub const TIMER_INTS_ALARM_3_ACCESS: &[u8; 3] = b"RO\0";
pub const TIMER_INTS_ALARM_2_ACCESS: &[u8; 3] = b"RO\0";
pub const TIMER_INTS_ALARM_1_ACCESS: &[u8; 3] = b"RO\0";
pub const TIMER_INTS_ALARM_0_ACCESS: &[u8; 3] = b"RO\0";
pub const PARAM_ASSERTIONS_ENABLED_TIMER: u32 = 0;
pub const PARAM_ASSERTIONS_ENABLED_TIME: u32 = 0;
pub const PICO_TIME_SLEEP_OVERHEAD_ADJUST_US: u32 = 6;
pub const PICO_TIME_DEFAULT_ALARM_POOL_DISABLED: u32 = 0;
pub const PICO_TIME_DEFAULT_ALARM_POOL_HARDWARE_ALARM_NUM: u32 = 3;
pub const PICO_TIME_DEFAULT_ALARM_POOL_MAX_TIMERS: u32 = 16;
pub const PADS_BANK0_VOLTAGE_SELECT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO0_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO0_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO0_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO0_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO0_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO0_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO0_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO1_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO1_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO1_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO1_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO1_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO1_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO1_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO2_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO2_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO2_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO2_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO2_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO2_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO2_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO3_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO3_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO3_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO3_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO3_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO3_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO3_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO4_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO4_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO4_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO4_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO4_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO4_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO4_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO5_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO5_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO5_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO5_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO5_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO5_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO5_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO6_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO6_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO6_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO6_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO6_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO6_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO6_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO7_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO7_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO7_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO7_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO7_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO7_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO7_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO8_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO8_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO8_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO8_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO8_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO8_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO8_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO9_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO9_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO9_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO9_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO9_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO9_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO9_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO10_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO10_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO10_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO10_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO10_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO10_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO10_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO11_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO11_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO11_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO11_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO11_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO11_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO11_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO12_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO12_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO12_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO12_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO12_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO12_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO12_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO13_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO13_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO13_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO13_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO13_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO13_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO13_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO14_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO14_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO14_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO14_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO14_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO14_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO14_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO15_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO15_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO15_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO15_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO15_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO15_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO15_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO16_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO16_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO16_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO16_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO16_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO16_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO16_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO17_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO17_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO17_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO17_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO17_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO17_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO17_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO18_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO18_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO18_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO18_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO18_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO18_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO18_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO19_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO19_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO19_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO19_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO19_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO19_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO19_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO20_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO20_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO20_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO20_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO20_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO20_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO20_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO21_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO21_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO21_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO21_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO21_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO21_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO21_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO22_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO22_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO22_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO22_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO22_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO22_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO22_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO23_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO23_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO23_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO23_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO23_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO23_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO23_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO24_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO24_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO24_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO24_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO24_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO24_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO24_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO25_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO25_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO25_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO25_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO25_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO25_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO25_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO26_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO26_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO26_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO26_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO26_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO26_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO26_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO27_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO27_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO27_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO27_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO27_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO27_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO27_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO28_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO28_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO28_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO28_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO28_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO28_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO28_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO29_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO29_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO29_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO29_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO29_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO29_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_GPIO29_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWCLK_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWCLK_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWCLK_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWCLK_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWCLK_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWCLK_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWCLK_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWD_OD_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWD_IE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWD_DRIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWD_PUE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWD_PDE_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWD_SCHMITT_ACCESS: &[u8; 3] = b"RW\0";
pub const PADS_BANK0_SWD_SLEWFAST_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO0_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO0_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO0_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO0_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO0_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO0_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO1_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO1_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO1_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO1_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO1_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO1_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO2_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO2_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO2_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO2_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO2_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO2_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO3_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO3_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO3_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO3_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO3_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO3_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO4_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO4_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO4_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO4_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO4_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO4_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO5_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO5_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO5_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO5_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO5_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO5_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO6_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO6_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO6_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO6_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO6_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO6_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO7_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO7_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO7_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO7_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO7_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO7_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO8_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO8_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO8_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO8_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO8_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO8_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO9_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO9_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO9_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO9_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO9_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO9_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO10_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO10_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO10_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO10_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO10_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO10_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO11_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO11_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO11_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO11_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO11_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO11_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO12_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO12_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO12_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO12_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO12_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO12_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO13_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO13_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO13_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO13_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO13_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO13_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO14_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO14_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO14_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO14_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO14_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO14_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO15_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO15_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO15_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO15_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO15_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO15_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO16_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO16_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO16_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO16_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO16_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO16_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO17_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO17_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO17_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO17_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO17_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO17_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO18_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO18_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO18_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO18_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO18_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO18_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO19_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO19_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO19_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO19_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO19_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO19_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO20_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO20_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO20_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO20_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO20_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO20_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO21_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO21_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO21_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO21_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO21_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO21_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO22_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO22_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO22_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO22_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO22_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO22_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO23_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO23_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO23_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO23_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO23_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO23_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO24_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO24_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO24_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO24_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO24_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO24_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO25_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO25_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO25_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO25_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO25_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO25_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO26_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO26_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO26_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO26_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO26_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO26_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO27_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO27_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO27_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO27_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO27_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO27_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO28_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO28_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO28_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO28_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO28_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO28_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO29_STATUS_IRQTOPROC_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_IRQFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_INTOPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_INFROMPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_OETOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_OEFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_OUTTOPAD_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_OUTFROMPERI_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_GPIO29_CTRL_IRQOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO29_CTRL_INOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO29_CTRL_OEOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO29_CTRL_OUTOVER_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_GPIO29_CTRL_FUNCSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_INTR0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTE0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC0_INTS0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTE0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_PROC1_INTS0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3] = b"RO\0";
pub const PICO_MAX_SHARED_IRQ_HANDLERS: u32 = 4;
pub const PICO_DISABLE_SHARED_IRQ_HANDLERS: u32 = 0;
pub const PICO_VTABLE_PER_CORE: u32 = 0;
pub const TIMER_IRQ_0: u32 = 0;
pub const TIMER_IRQ_1: u32 = 1;
pub const TIMER_IRQ_2: u32 = 2;
pub const TIMER_IRQ_3: u32 = 3;
pub const PWM_IRQ_WRAP: u32 = 4;
pub const USBCTRL_IRQ: u32 = 5;
pub const XIP_IRQ: u32 = 6;
pub const PIO0_IRQ_0: u32 = 7;
pub const PIO0_IRQ_1: u32 = 8;
pub const PIO1_IRQ_0: u32 = 9;
pub const PIO1_IRQ_1: u32 = 10;
pub const DMA_IRQ_0: u32 = 11;
pub const DMA_IRQ_1: u32 = 12;
pub const IO_IRQ_BANK0: u32 = 13;
pub const IO_IRQ_QSPI: u32 = 14;
pub const SIO_IRQ_PROC0: u32 = 15;
pub const SIO_IRQ_PROC1: u32 = 16;
pub const CLOCKS_IRQ: u32 = 17;
pub const SPI0_IRQ: u32 = 18;
pub const SPI1_IRQ: u32 = 19;
pub const UART0_IRQ: u32 = 20;
pub const UART1_IRQ: u32 = 21;
pub const ADC_IRQ_FIFO: u32 = 22;
pub const I2C0_IRQ: u32 = 23;
pub const I2C1_IRQ: u32 = 24;
pub const RTC_IRQ: u32 = 25;
pub const M0PLUS_SYST_CSR_COUNTFLAG_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_SYST_CSR_CLKSOURCE_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_SYST_CSR_TICKINT_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_SYST_CSR_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_SYST_RVR_RELOAD_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_SYST_CVR_CURRENT_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_SYST_CALIB_NOREF_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_SYST_CALIB_SKEW_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_SYST_CALIB_TENMS_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_NVIC_ISER_SETENA_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_ICER_CLRENA_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_ISPR_SETPEND_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_ICPR_CLRPEND_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR0_IP_3_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR0_IP_2_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR0_IP_1_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR0_IP_0_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR1_IP_7_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR1_IP_6_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR1_IP_5_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR1_IP_4_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR2_IP_11_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR2_IP_10_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR2_IP_9_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR2_IP_8_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR3_IP_15_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR3_IP_14_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR3_IP_13_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR3_IP_12_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR4_IP_19_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR4_IP_18_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR4_IP_17_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR4_IP_16_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR5_IP_23_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR5_IP_22_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR5_IP_21_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR5_IP_20_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR6_IP_27_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR6_IP_26_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR6_IP_25_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR6_IP_24_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR7_IP_31_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR7_IP_30_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR7_IP_29_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_NVIC_IPR7_IP_28_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_CPUID_IMPLEMENTER_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_CPUID_VARIANT_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_CPUID_ARCHITECTURE_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_CPUID_PARTNO_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_CPUID_REVISION_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_ICSR_NMIPENDSET_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_ICSR_PENDSVSET_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_ICSR_PENDSVCLR_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_ICSR_PENDSTSET_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_ICSR_PENDSTCLR_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_ICSR_ISRPREEMPT_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_ICSR_ISRPENDING_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_ICSR_VECTPENDING_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_ICSR_VECTACTIVE_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_VTOR_TBLOFF_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_AIRCR_VECTKEY_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_AIRCR_ENDIANESS_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_AIRCR_SYSRESETREQ_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_AIRCR_VECTCLRACTIVE_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_SCR_SEVONPEND_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_SCR_SLEEPDEEP_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_SCR_SLEEPONEXIT_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_CCR_STKALIGN_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_CCR_UNALIGN_TRP_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_SHPR2_PRI_11_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_SHPR3_PRI_15_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_SHPR3_PRI_14_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_SHCSR_SVCALLPENDED_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_MPU_TYPE_IREGION_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_MPU_TYPE_DREGION_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_MPU_TYPE_SEPARATE_ACCESS: &[u8; 3] = b"RO\0";
pub const M0PLUS_MPU_CTRL_PRIVDEFENA_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_MPU_CTRL_HFNMIENA_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_MPU_CTRL_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_MPU_RNR_REGION_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_MPU_RBAR_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_MPU_RBAR_VALID_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_MPU_RBAR_REGION_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_MPU_RASR_ATTRS_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_MPU_RASR_SRD_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_MPU_RASR_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const M0PLUS_MPU_RASR_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const PICO_DEFAULT_IRQ_PRIORITY: u32 = 128;
pub const PICO_LOWEST_IRQ_PRIORITY: u32 = 255;
pub const PICO_HIGHEST_IRQ_PRIORITY: u32 = 0;
pub const PICO_SHARED_IRQ_HANDLER_DEFAULT_ORDER_PRIORITY: u32 = 128;
pub const PICO_SHARED_IRQ_HANDLER_HIGHEST_ORDER_PRIORITY: u32 = 255;
pub const PICO_SHARED_IRQ_HANDLER_LOWEST_ORDER_PRIORITY: u32 = 0;
pub const PARAM_ASSERTIONS_ENABLED_IRQ: u32 = 0;
pub const PARAM_ASSERTIONS_ENABLED_GPIO: u32 = 0;
pub const GPIO_OUT: u32 = 1;
pub const GPIO_IN: u32 = 0;
pub const GPIO_IRQ_CALLBACK_ORDER_PRIORITY: u32 = 0;
pub const GPIO_RAW_IRQ_HANDLER_DEFAULT_ORDER_PRIORITY: u32 = 128;
pub const PICO_DEBUG_PIN_BASE: u32 = 19;
pub const PICO_DEBUG_PIN_COUNT: u32 = 3;
pub const UART_UARTDR_OE_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTDR_OE_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTDR_BE_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTDR_BE_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTDR_PE_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTDR_PE_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTDR_FE_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTDR_FE_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTDR_DATA_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTDR_DATA_ACCESS: &[u8; 4] = b"RWF\0";
pub const UART_UARTRSR_OE_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTRSR_BE_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTRSR_PE_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTRSR_FE_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTFR_RI_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTFR_RI_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTFR_TXFE_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTFR_RXFF_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTFR_TXFF_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTFR_RXFE_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTFR_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTFR_DCD_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTFR_DCD_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTFR_DSR_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTFR_DSR_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTFR_CTS_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTFR_CTS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTILPR_ILPDVSR_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIBRD_BAUD_DIVINT_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTFBRD_BAUD_DIVFRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTLCR_H_SPS_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTLCR_H_WLEN_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTLCR_H_FEN_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTLCR_H_STP2_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTLCR_H_EPS_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTLCR_H_PEN_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTLCR_H_BRK_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTCR_CTSEN_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTCR_RTSEN_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTCR_OUT2_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTCR_OUT1_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTCR_RTS_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTCR_DTR_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTCR_RXE_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTCR_TXE_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTCR_LBE_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTCR_SIRLP_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTCR_SIREN_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTCR_UARTEN_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIFLS_RXIFLSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIFLS_TXIFLSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIMSC_OEIM_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIMSC_BEIM_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIMSC_PEIM_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIMSC_FEIM_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIMSC_RTIM_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIMSC_TXIM_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIMSC_RXIM_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIMSC_DSRMIM_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIMSC_DCDMIM_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIMSC_CTSMIM_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTIMSC_RIMIM_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTRIS_OERIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTRIS_BERIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTRIS_PERIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTRIS_FERIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTRIS_RTRIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTRIS_TXRIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTRIS_RXRIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTRIS_DSRRMIS_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTRIS_DSRRMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTRIS_DCDRMIS_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTRIS_DCDRMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTRIS_CTSRMIS_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTRIS_CTSRMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTRIS_RIRMIS_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTRIS_RIRMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTMIS_OEMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTMIS_BEMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTMIS_PEMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTMIS_FEMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTMIS_RTMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTMIS_TXMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTMIS_RXMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTMIS_DSRMMIS_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTMIS_DSRMMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTMIS_DCDMMIS_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTMIS_DCDMMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTMIS_CTSMMIS_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTMIS_CTSMMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTMIS_RIMMIS_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTMIS_RIMMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTICR_OEIC_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTICR_OEIC_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTICR_BEIC_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTICR_BEIC_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTICR_PEIC_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTICR_PEIC_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTICR_FEIC_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTICR_FEIC_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTICR_RTIC_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTICR_RTIC_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTICR_TXIC_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTICR_TXIC_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTICR_RXIC_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTICR_RXIC_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTICR_DSRMIC_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTICR_DSRMIC_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTICR_DCDMIC_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTICR_DCDMIC_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTICR_CTSMIC_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTICR_CTSMIC_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTICR_RIMIC_RESET: &[u8; 2] = b"-\0";
pub const UART_UARTICR_RIMIC_ACCESS: &[u8; 3] = b"WC\0";
pub const UART_UARTDMACR_DMAONERR_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTDMACR_TXDMAE_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTDMACR_RXDMAE_ACCESS: &[u8; 3] = b"RW\0";
pub const UART_UARTPERIPHID0_PARTNUMBER0_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTPERIPHID1_DESIGNER0_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTPERIPHID1_PARTNUMBER1_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTPERIPHID2_REVISION_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTPERIPHID2_DESIGNER1_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTPERIPHID3_CONFIGURATION_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTPCELLID0_UARTPCELLID0_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTPCELLID1_UARTPCELLID1_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTPCELLID2_UARTPCELLID2_ACCESS: &[u8; 3] = b"RO\0";
pub const UART_UARTPCELLID3_UARTPCELLID3_ACCESS: &[u8; 3] = b"RO\0";
pub const DREQ_PIO0_TX0: u32 = 0;
pub const DREQ_PIO0_TX1: u32 = 1;
pub const DREQ_PIO0_TX2: u32 = 2;
pub const DREQ_PIO0_TX3: u32 = 3;
pub const DREQ_PIO0_RX0: u32 = 4;
pub const DREQ_PIO0_RX1: u32 = 5;
pub const DREQ_PIO0_RX2: u32 = 6;
pub const DREQ_PIO0_RX3: u32 = 7;
pub const DREQ_PIO1_TX0: u32 = 8;
pub const DREQ_PIO1_TX1: u32 = 9;
pub const DREQ_PIO1_TX2: u32 = 10;
pub const DREQ_PIO1_TX3: u32 = 11;
pub const DREQ_PIO1_RX0: u32 = 12;
pub const DREQ_PIO1_RX1: u32 = 13;
pub const DREQ_PIO1_RX2: u32 = 14;
pub const DREQ_PIO1_RX3: u32 = 15;
pub const DREQ_SPI0_TX: u32 = 16;
pub const DREQ_SPI0_RX: u32 = 17;
pub const DREQ_SPI1_TX: u32 = 18;
pub const DREQ_SPI1_RX: u32 = 19;
pub const DREQ_UART0_TX: u32 = 20;
pub const DREQ_UART0_RX: u32 = 21;
pub const DREQ_UART1_TX: u32 = 22;
pub const DREQ_UART1_RX: u32 = 23;
pub const DREQ_PWM_WRAP0: u32 = 24;
pub const DREQ_PWM_WRAP1: u32 = 25;
pub const DREQ_PWM_WRAP2: u32 = 26;
pub const DREQ_PWM_WRAP3: u32 = 27;
pub const DREQ_PWM_WRAP4: u32 = 28;
pub const DREQ_PWM_WRAP5: u32 = 29;
pub const DREQ_PWM_WRAP6: u32 = 30;
pub const DREQ_PWM_WRAP7: u32 = 31;
pub const DREQ_I2C0_TX: u32 = 32;
pub const DREQ_I2C0_RX: u32 = 33;
pub const DREQ_I2C1_TX: u32 = 34;
pub const DREQ_I2C1_RX: u32 = 35;
pub const DREQ_ADC: u32 = 36;
pub const DREQ_XIP_STREAM: u32 = 37;
pub const DREQ_XIP_SSITX: u32 = 38;
pub const DREQ_XIP_SSIRX: u32 = 39;
pub const PARAM_ASSERTIONS_ENABLED_UART: u32 = 0;
pub const PICO_UART_ENABLE_CRLF_SUPPORT: u32 = 1;
pub const PICO_UART_DEFAULT_CRLF: u32 = 0;
pub const PICO_DEFAULT_UART_BAUD_RATE: u32 = 115200;
pub const PICO_DEFAULT_LED_PIN_INVERTED: u32 = 0;
pub const ADC_CS_RROBIN_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_CS_AINSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_CS_ERR_STICKY_ACCESS: &[u8; 3] = b"WC\0";
pub const ADC_CS_ERR_ACCESS: &[u8; 3] = b"RO\0";
pub const ADC_CS_READY_ACCESS: &[u8; 3] = b"RO\0";
pub const ADC_CS_START_MANY_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_CS_START_ONCE_ACCESS: &[u8; 3] = b"SC\0";
pub const ADC_CS_TS_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_CS_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_RESULT_ACCESS: &[u8; 3] = b"RO\0";
pub const ADC_FCS_THRESH_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_FCS_LEVEL_ACCESS: &[u8; 3] = b"RO\0";
pub const ADC_FCS_OVER_ACCESS: &[u8; 3] = b"WC\0";
pub const ADC_FCS_UNDER_ACCESS: &[u8; 3] = b"WC\0";
pub const ADC_FCS_FULL_ACCESS: &[u8; 3] = b"RO\0";
pub const ADC_FCS_EMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const ADC_FCS_DREQ_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_FCS_ERR_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_FCS_SHIFT_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_FCS_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_FIFO_ERR_RESET: &[u8; 2] = b"-\0";
pub const ADC_FIFO_ERR_ACCESS: &[u8; 3] = b"RF\0";
pub const ADC_FIFO_VAL_RESET: &[u8; 2] = b"-\0";
pub const ADC_FIFO_VAL_ACCESS: &[u8; 3] = b"RF\0";
pub const ADC_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_INTR_FIFO_ACCESS: &[u8; 3] = b"RO\0";
pub const ADC_INTE_FIFO_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_INTF_FIFO_ACCESS: &[u8; 3] = b"RW\0";
pub const ADC_INTS_FIFO_ACCESS: &[u8; 3] = b"RO\0";
pub const PARAM_ASSERTIONS_ENABLED_ADC: u32 = 0;
pub const SPI_SSPCR0_SCR_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPCR0_SPH_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPCR0_SPO_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPCR0_FRF_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPCR0_DSS_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPCR1_SOD_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPCR1_MS_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPCR1_SSE_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPCR1_LBM_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPDR_RESET: &[u8; 2] = b"-\0";
pub const SPI_SSPDR_DATA_RESET: &[u8; 2] = b"-\0";
pub const SPI_SSPDR_DATA_ACCESS: &[u8; 4] = b"RWF\0";
pub const SPI_SSPSR_BSY_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPSR_RFF_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPSR_RNE_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPSR_TNF_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPSR_TFE_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPCPSR_CPSDVSR_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPIMSC_TXIM_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPIMSC_RXIM_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPIMSC_RTIM_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPIMSC_RORIM_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPRIS_TXRIS_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPRIS_RXRIS_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPRIS_RTRIS_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPRIS_RORRIS_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPMIS_TXMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPMIS_RXMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPMIS_RTMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPMIS_RORMIS_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPICR_RTIC_ACCESS: &[u8; 3] = b"WC\0";
pub const SPI_SSPICR_RORIC_ACCESS: &[u8; 3] = b"WC\0";
pub const SPI_SSPDMACR_TXDMAE_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPDMACR_RXDMAE_ACCESS: &[u8; 3] = b"RW\0";
pub const SPI_SSPPERIPHID0_PARTNUMBER0_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPPERIPHID1_DESIGNER0_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPPERIPHID1_PARTNUMBER1_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPPERIPHID2_REVISION_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPPERIPHID2_DESIGNER1_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPPERIPHID3_CONFIGURATION_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPPCELLID0_SSPPCELLID0_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPPCELLID1_SSPPCELLID1_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPPCELLID2_SSPPCELLID2_ACCESS: &[u8; 3] = b"RO\0";
pub const SPI_SSPPCELLID3_SSPPCELLID3_ACCESS: &[u8; 3] = b"RO\0";
pub const PARAM_ASSERTIONS_ENABLED_SPI: u32 = 0;
pub const I2C_IC_CON_STOP_DET_IF_MASTER_ACTIVE_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_CON_RX_FIFO_FULL_HLD_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_CON_TX_EMPTY_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_CON_STOP_DET_IFADDRESSED_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_CON_IC_SLAVE_DISABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_CON_IC_RESTART_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_CON_IC_10BITADDR_MASTER_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_CON_IC_10BITADDR_SLAVE_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_CON_SPEED_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_CON_MASTER_MODE_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_TAR_SPECIAL_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_TAR_GC_OR_START_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_TAR_IC_TAR_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_SAR_IC_SAR_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_DATA_CMD_FIRST_DATA_BYTE_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_DATA_CMD_RESTART_ACCESS: &[u8; 3] = b"SC\0";
pub const I2C_IC_DATA_CMD_STOP_ACCESS: &[u8; 3] = b"SC\0";
pub const I2C_IC_DATA_CMD_CMD_ACCESS: &[u8; 3] = b"SC\0";
pub const I2C_IC_DATA_CMD_DAT_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_INTR_STAT_R_RESTART_DET_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_INTR_STAT_R_GEN_CALL_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_INTR_STAT_R_START_DET_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_INTR_STAT_R_STOP_DET_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_INTR_STAT_R_ACTIVITY_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_INTR_STAT_R_RX_DONE_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_INTR_STAT_R_TX_ABRT_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_INTR_STAT_R_RD_REQ_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_INTR_STAT_R_TX_EMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_INTR_STAT_R_TX_OVER_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_INTR_STAT_R_RX_FULL_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_INTR_STAT_R_RX_OVER_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_INTR_STAT_R_RX_UNDER_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_INTR_MASK_M_RESTART_DET_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_INTR_MASK_M_GEN_CALL_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_INTR_MASK_M_START_DET_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_INTR_MASK_M_STOP_DET_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_INTR_MASK_M_ACTIVITY_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_INTR_MASK_M_RX_DONE_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_INTR_MASK_M_TX_ABRT_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_INTR_MASK_M_RD_REQ_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_INTR_MASK_M_TX_EMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_INTR_MASK_M_TX_OVER_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_INTR_MASK_M_RX_FULL_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_INTR_MASK_M_RX_OVER_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_INTR_MASK_M_RX_UNDER_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_RAW_INTR_STAT_RESTART_DET_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RAW_INTR_STAT_GEN_CALL_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RAW_INTR_STAT_START_DET_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RAW_INTR_STAT_STOP_DET_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RAW_INTR_STAT_ACTIVITY_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RAW_INTR_STAT_RX_DONE_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RAW_INTR_STAT_TX_ABRT_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RAW_INTR_STAT_RD_REQ_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RAW_INTR_STAT_TX_EMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RAW_INTR_STAT_TX_OVER_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RAW_INTR_STAT_RX_FULL_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RAW_INTR_STAT_RX_OVER_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RAW_INTR_STAT_RX_UNDER_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RX_TL_RX_TL_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_TX_TL_TX_TL_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_CLR_INTR_CLR_INTR_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_CLR_RX_UNDER_CLR_RX_UNDER_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_CLR_RX_OVER_CLR_RX_OVER_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_CLR_TX_OVER_CLR_TX_OVER_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_CLR_RD_REQ_CLR_RD_REQ_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_CLR_TX_ABRT_CLR_TX_ABRT_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_CLR_RX_DONE_CLR_RX_DONE_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_CLR_ACTIVITY_CLR_ACTIVITY_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_CLR_STOP_DET_CLR_STOP_DET_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_CLR_START_DET_CLR_START_DET_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_CLR_GEN_CALL_CLR_GEN_CALL_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_ENABLE_TX_CMD_BLOCK_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_ENABLE_ABORT_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_ENABLE_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_STATUS_SLV_ACTIVITY_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_STATUS_MST_ACTIVITY_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_STATUS_RFF_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_STATUS_RFNE_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_STATUS_TFE_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_STATUS_TFNF_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_STATUS_ACTIVITY_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TXFLR_TXFLR_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_RXFLR_RXFLR_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_SDA_HOLD_IC_SDA_RX_HOLD_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_SDA_HOLD_IC_SDA_TX_HOLD_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ARB_LOST_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_SLV_DATA_NACK_ONLY_NACK_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_DMA_CR_TDMAE_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_DMA_CR_RDMAE_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_DMA_TDLR_DMATDL_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_DMA_RDLR_DMARDL_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_SDA_SETUP_SDA_SETUP_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_ENABLE_STATUS_IC_EN_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_FS_SPKLEN_IC_FS_SPKLEN_ACCESS: &[u8; 3] = b"RW\0";
pub const I2C_IC_CLR_RESTART_DET_CLR_RESTART_DET_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_COMP_PARAM_1_HAS_DMA_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_COMP_PARAM_1_INTR_IO_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_COMP_PARAM_1_HC_COUNT_VALUES_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_COMP_PARAM_1_MAX_SPEED_MODE_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_COMP_PARAM_1_APB_DATA_WIDTH_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_COMP_VERSION_IC_COMP_VERSION_ACCESS: &[u8; 3] = b"RO\0";
pub const I2C_IC_COMP_TYPE_IC_COMP_TYPE_ACCESS: &[u8; 3] = b"RO\0";
pub const PARAM_ASSERTIONS_ENABLED_I2C: u32 = 0;
pub const PARAM_ASSERTIONS_ENABLED_SYNC: u32 = 0;
pub const PICO_SPINLOCK_ID_IRQ: u32 = 9;
pub const PICO_SPINLOCK_ID_TIMER: u32 = 10;
pub const PICO_SPINLOCK_ID_HARDWARE_CLAIM: u32 = 11;
pub const PICO_SPINLOCK_ID_RAND: u32 = 12;
pub const PICO_SPINLOCK_ID_OS1: u32 = 14;
pub const PICO_SPINLOCK_ID_OS2: u32 = 15;
pub const PICO_SPINLOCK_ID_STRIPED_FIRST: u32 = 16;
pub const PICO_SPINLOCK_ID_STRIPED_LAST: u32 = 23;
pub const PICO_SPINLOCK_ID_CLAIM_FREE_FIRST: u32 = 24;
pub const PICO_SPINLOCK_ID_CLAIM_FREE_LAST: u32 = 31;
pub const CLOCKS_CLK_GPOUT0_CTRL_NUDGE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT0_CTRL_PHASE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT0_CTRL_DC50_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT0_CTRL_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT0_CTRL_KILL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT0_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT0_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT0_SELECTED_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_CLK_GPOUT1_CTRL_NUDGE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT1_CTRL_PHASE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT1_CTRL_DC50_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT1_CTRL_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT1_CTRL_KILL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT1_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT1_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT1_SELECTED_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_CLK_GPOUT2_CTRL_NUDGE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT2_CTRL_PHASE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT2_CTRL_DC50_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT2_CTRL_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT2_CTRL_KILL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT2_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT2_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT2_SELECTED_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_CLK_GPOUT3_CTRL_NUDGE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT3_CTRL_PHASE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT3_CTRL_DC50_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT3_CTRL_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT3_CTRL_KILL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT3_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT3_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_GPOUT3_SELECTED_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_CLK_REF_CTRL_AUXSRC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_REF_CTRL_SRC_RESET: &[u8; 2] = b"-\0";
pub const CLOCKS_CLK_REF_CTRL_SRC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_REF_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_REF_SELECTED_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_CLK_SYS_CTRL_AUXSRC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_SYS_CTRL_SRC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_SYS_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_SYS_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_SYS_SELECTED_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_CLK_PERI_CTRL_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_PERI_CTRL_KILL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_PERI_CTRL_AUXSRC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_PERI_SELECTED_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_CLK_USB_CTRL_NUDGE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_USB_CTRL_PHASE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_USB_CTRL_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_USB_CTRL_KILL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_USB_CTRL_AUXSRC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_USB_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_USB_SELECTED_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_CLK_ADC_CTRL_NUDGE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_ADC_CTRL_PHASE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_ADC_CTRL_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_ADC_CTRL_KILL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_ADC_CTRL_AUXSRC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_ADC_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_ADC_SELECTED_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_CLK_RTC_CTRL_NUDGE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_RTC_CTRL_PHASE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_RTC_CTRL_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_RTC_CTRL_KILL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_RTC_CTRL_AUXSRC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_RTC_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_RTC_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_RTC_SELECTED_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_CLK_SYS_RESUS_CTRL_CLEAR_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_SYS_RESUS_CTRL_FRCE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_SYS_RESUS_CTRL_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_SYS_RESUS_CTRL_TIMEOUT_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_CLK_SYS_RESUS_STATUS_RESUSSED_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_FC0_REF_KHZ_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_FC0_MIN_KHZ_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_FC0_MAX_KHZ_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_FC0_DELAY_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_FC0_INTERVAL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_FC0_SRC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_FC0_STATUS_DIED_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_FC0_STATUS_FAST_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_FC0_STATUS_SLOW_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_FC0_STATUS_FAIL_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_FC0_STATUS_WAITING_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_FC0_STATUS_RUNNING_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_FC0_STATUS_DONE_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_FC0_STATUS_PASS_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_FC0_RESULT_KHZ_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_FC0_RESULT_FRAC_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_SRAM3_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_SRAM2_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_SRAM1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_SRAM0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_SPI1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_PERI_SPI1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_SPI0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_PERI_SPI0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_SIO_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_RTC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_RTC_RTC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_ROSC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_ROM_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_RESETS_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_PWM_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_PSM_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_PLL_USB_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_PLL_SYS_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_PIO1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_PIO0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_PADS_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_VREG_AND_CHIP_RESET_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_JTAG_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_IO_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_I2C1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_I2C0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_DMA_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_BUSFABRIC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_BUSCTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_ADC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_ADC_ADC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN0_CLK_SYS_CLOCKS_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_SYS_XOSC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_SYS_XIP_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_SYS_WATCHDOG_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_USB_USBCTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_SYS_USBCTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_SYS_UART1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_PERI_UART1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_SYS_UART0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_PERI_UART0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_SYS_TIMER_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_SYS_TBMAN_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_SYS_SYSINFO_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_SYS_SYSCFG_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_SYS_SRAM5_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_WAKE_EN1_CLK_SYS_SRAM4_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_SRAM3_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_SRAM2_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_SRAM1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_SRAM0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_SPI1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_PERI_SPI1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_SPI0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_PERI_SPI0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_SIO_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_RTC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_RTC_RTC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_ROSC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_ROM_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_RESETS_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_PWM_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_PSM_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_PLL_USB_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_PLL_SYS_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_PIO1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_PIO0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_PADS_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_VREG_AND_CHIP_RESET_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_JTAG_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_IO_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_I2C1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_I2C0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_DMA_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_BUSFABRIC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_BUSCTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_ADC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_ADC_ADC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN0_CLK_SYS_CLOCKS_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_SYS_XOSC_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_SYS_XIP_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_SYS_WATCHDOG_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_USB_USBCTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_SYS_USBCTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_SYS_UART1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_PERI_UART1_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_SYS_UART0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_PERI_UART0_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_SYS_TIMER_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_SYS_TBMAN_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_SYS_SYSINFO_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_SYS_SYSCFG_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_SYS_SRAM5_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_SLEEP_EN1_CLK_SYS_SRAM4_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_ENABLED0_CLK_SYS_SRAM3_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_SRAM2_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_SRAM1_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_SRAM0_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_SPI1_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_PERI_SPI1_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_SPI0_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_PERI_SPI0_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_SIO_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_RTC_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_RTC_RTC_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_ROSC_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_ROM_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_RESETS_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_PWM_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_PSM_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_PLL_USB_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_PLL_SYS_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_PIO1_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_PIO0_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_PADS_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_VREG_AND_CHIP_RESET_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_JTAG_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_IO_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_I2C1_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_I2C0_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_DMA_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_BUSFABRIC_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_BUSCTRL_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_ADC_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_ADC_ADC_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED0_CLK_SYS_CLOCKS_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_SYS_XOSC_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_SYS_XIP_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_SYS_WATCHDOG_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_USB_USBCTRL_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_SYS_USBCTRL_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_SYS_UART1_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_PERI_UART1_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_SYS_UART0_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_PERI_UART0_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_SYS_TIMER_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_SYS_TBMAN_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_SYS_SYSINFO_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_SYS_SYSCFG_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_SYS_SRAM5_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_ENABLED1_CLK_SYS_SRAM4_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_INTR_CLK_SYS_RESUS_ACCESS: &[u8; 3] = b"RO\0";
pub const CLOCKS_INTE_CLK_SYS_RESUS_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_INTF_CLK_SYS_RESUS_ACCESS: &[u8; 3] = b"RW\0";
pub const CLOCKS_INTS_CLK_SYS_RESUS_ACCESS: &[u8; 3] = b"RO\0";
pub const KHZ: u32 = 1000;
pub const MHZ: u32 = 1000000;
pub const PLL_COMMON_REFDIV: u32 = 1;
pub const PLL_SYS_VCO_FREQ_KHZ: u32 = 1500000;
pub const PLL_SYS_POSTDIV1: u32 = 6;
pub const PLL_SYS_POSTDIV2: u32 = 2;
pub const PLL_USB_VCO_FREQ_KHZ: u32 = 1200000;
pub const PLL_USB_POSTDIV1: u32 = 5;
pub const PLL_USB_POSTDIV2: u32 = 5;
pub const PARAM_ASSERTIONS_ENABLED_CLOCKS: u32 = 0;
pub const DMA_CH0_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_CTRL_TRIG_AHB_ERROR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH0_CTRL_TRIG_READ_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH0_CTRL_TRIG_WRITE_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH0_CTRL_TRIG_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH0_CTRL_TRIG_SNIFF_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_CTRL_TRIG_BSWAP_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_CTRL_TRIG_IRQ_QUIET_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_CTRL_TRIG_TREQ_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_CTRL_TRIG_CHAIN_TO_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_CTRL_TRIG_RING_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_CTRL_TRIG_RING_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_CTRL_TRIG_INCR_WRITE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_CTRL_TRIG_INCR_READ_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_CTRL_TRIG_DATA_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_CTRL_TRIG_HIGH_PRIORITY_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_CTRL_TRIG_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_AL1_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH0_AL1_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_AL1_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH0_AL1_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_AL1_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH0_AL1_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_AL1_TRANS_COUNT_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH0_AL1_TRANS_COUNT_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_AL2_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH0_AL2_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_AL2_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH0_AL2_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_AL2_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH0_AL2_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_AL2_WRITE_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH0_AL2_WRITE_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_AL3_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH0_AL3_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_AL3_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH0_AL3_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_AL3_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH0_AL3_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH0_AL3_READ_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH0_AL3_READ_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_CTRL_TRIG_AHB_ERROR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH1_CTRL_TRIG_READ_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH1_CTRL_TRIG_WRITE_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH1_CTRL_TRIG_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH1_CTRL_TRIG_SNIFF_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_CTRL_TRIG_BSWAP_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_CTRL_TRIG_IRQ_QUIET_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_CTRL_TRIG_TREQ_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_CTRL_TRIG_CHAIN_TO_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_CTRL_TRIG_RING_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_CTRL_TRIG_RING_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_CTRL_TRIG_INCR_WRITE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_CTRL_TRIG_INCR_READ_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_CTRL_TRIG_DATA_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_CTRL_TRIG_HIGH_PRIORITY_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_CTRL_TRIG_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_AL1_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH1_AL1_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_AL1_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH1_AL1_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_AL1_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH1_AL1_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_AL1_TRANS_COUNT_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH1_AL1_TRANS_COUNT_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_AL2_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH1_AL2_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_AL2_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH1_AL2_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_AL2_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH1_AL2_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_AL2_WRITE_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH1_AL2_WRITE_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_AL3_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH1_AL3_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_AL3_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH1_AL3_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_AL3_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH1_AL3_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH1_AL3_READ_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH1_AL3_READ_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_CTRL_TRIG_AHB_ERROR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH2_CTRL_TRIG_READ_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH2_CTRL_TRIG_WRITE_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH2_CTRL_TRIG_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH2_CTRL_TRIG_SNIFF_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_CTRL_TRIG_BSWAP_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_CTRL_TRIG_IRQ_QUIET_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_CTRL_TRIG_TREQ_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_CTRL_TRIG_CHAIN_TO_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_CTRL_TRIG_RING_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_CTRL_TRIG_RING_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_CTRL_TRIG_INCR_WRITE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_CTRL_TRIG_INCR_READ_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_CTRL_TRIG_DATA_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_CTRL_TRIG_HIGH_PRIORITY_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_CTRL_TRIG_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_AL1_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH2_AL1_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_AL1_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH2_AL1_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_AL1_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH2_AL1_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_AL1_TRANS_COUNT_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH2_AL1_TRANS_COUNT_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_AL2_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH2_AL2_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_AL2_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH2_AL2_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_AL2_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH2_AL2_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_AL2_WRITE_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH2_AL2_WRITE_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_AL3_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH2_AL3_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_AL3_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH2_AL3_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_AL3_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH2_AL3_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH2_AL3_READ_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH2_AL3_READ_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_CTRL_TRIG_AHB_ERROR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH3_CTRL_TRIG_READ_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH3_CTRL_TRIG_WRITE_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH3_CTRL_TRIG_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH3_CTRL_TRIG_SNIFF_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_CTRL_TRIG_BSWAP_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_CTRL_TRIG_IRQ_QUIET_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_CTRL_TRIG_TREQ_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_CTRL_TRIG_CHAIN_TO_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_CTRL_TRIG_RING_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_CTRL_TRIG_RING_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_CTRL_TRIG_INCR_WRITE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_CTRL_TRIG_INCR_READ_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_CTRL_TRIG_DATA_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_CTRL_TRIG_HIGH_PRIORITY_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_CTRL_TRIG_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_AL1_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH3_AL1_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_AL1_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH3_AL1_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_AL1_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH3_AL1_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_AL1_TRANS_COUNT_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH3_AL1_TRANS_COUNT_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_AL2_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH3_AL2_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_AL2_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH3_AL2_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_AL2_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH3_AL2_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_AL2_WRITE_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH3_AL2_WRITE_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_AL3_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH3_AL3_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_AL3_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH3_AL3_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_AL3_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH3_AL3_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH3_AL3_READ_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH3_AL3_READ_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_CTRL_TRIG_AHB_ERROR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH4_CTRL_TRIG_READ_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH4_CTRL_TRIG_WRITE_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH4_CTRL_TRIG_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH4_CTRL_TRIG_SNIFF_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_CTRL_TRIG_BSWAP_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_CTRL_TRIG_IRQ_QUIET_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_CTRL_TRIG_TREQ_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_CTRL_TRIG_CHAIN_TO_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_CTRL_TRIG_RING_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_CTRL_TRIG_RING_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_CTRL_TRIG_INCR_WRITE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_CTRL_TRIG_INCR_READ_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_CTRL_TRIG_DATA_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_CTRL_TRIG_HIGH_PRIORITY_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_CTRL_TRIG_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_AL1_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH4_AL1_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_AL1_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH4_AL1_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_AL1_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH4_AL1_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_AL1_TRANS_COUNT_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH4_AL1_TRANS_COUNT_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_AL2_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH4_AL2_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_AL2_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH4_AL2_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_AL2_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH4_AL2_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_AL2_WRITE_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH4_AL2_WRITE_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_AL3_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH4_AL3_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_AL3_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH4_AL3_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_AL3_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH4_AL3_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH4_AL3_READ_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH4_AL3_READ_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_CTRL_TRIG_AHB_ERROR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH5_CTRL_TRIG_READ_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH5_CTRL_TRIG_WRITE_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH5_CTRL_TRIG_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH5_CTRL_TRIG_SNIFF_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_CTRL_TRIG_BSWAP_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_CTRL_TRIG_IRQ_QUIET_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_CTRL_TRIG_TREQ_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_CTRL_TRIG_CHAIN_TO_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_CTRL_TRIG_RING_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_CTRL_TRIG_RING_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_CTRL_TRIG_INCR_WRITE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_CTRL_TRIG_INCR_READ_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_CTRL_TRIG_DATA_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_CTRL_TRIG_HIGH_PRIORITY_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_CTRL_TRIG_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_AL1_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH5_AL1_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_AL1_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH5_AL1_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_AL1_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH5_AL1_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_AL1_TRANS_COUNT_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH5_AL1_TRANS_COUNT_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_AL2_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH5_AL2_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_AL2_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH5_AL2_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_AL2_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH5_AL2_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_AL2_WRITE_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH5_AL2_WRITE_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_AL3_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH5_AL3_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_AL3_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH5_AL3_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_AL3_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH5_AL3_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH5_AL3_READ_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH5_AL3_READ_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_CTRL_TRIG_AHB_ERROR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH6_CTRL_TRIG_READ_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH6_CTRL_TRIG_WRITE_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH6_CTRL_TRIG_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH6_CTRL_TRIG_SNIFF_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_CTRL_TRIG_BSWAP_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_CTRL_TRIG_IRQ_QUIET_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_CTRL_TRIG_TREQ_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_CTRL_TRIG_CHAIN_TO_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_CTRL_TRIG_RING_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_CTRL_TRIG_RING_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_CTRL_TRIG_INCR_WRITE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_CTRL_TRIG_INCR_READ_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_CTRL_TRIG_DATA_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_CTRL_TRIG_HIGH_PRIORITY_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_CTRL_TRIG_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_AL1_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH6_AL1_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_AL1_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH6_AL1_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_AL1_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH6_AL1_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_AL1_TRANS_COUNT_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH6_AL1_TRANS_COUNT_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_AL2_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH6_AL2_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_AL2_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH6_AL2_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_AL2_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH6_AL2_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_AL2_WRITE_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH6_AL2_WRITE_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_AL3_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH6_AL3_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_AL3_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH6_AL3_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_AL3_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH6_AL3_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH6_AL3_READ_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH6_AL3_READ_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_CTRL_TRIG_AHB_ERROR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH7_CTRL_TRIG_READ_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH7_CTRL_TRIG_WRITE_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH7_CTRL_TRIG_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH7_CTRL_TRIG_SNIFF_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_CTRL_TRIG_BSWAP_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_CTRL_TRIG_IRQ_QUIET_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_CTRL_TRIG_TREQ_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_CTRL_TRIG_CHAIN_TO_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_CTRL_TRIG_RING_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_CTRL_TRIG_RING_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_CTRL_TRIG_INCR_WRITE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_CTRL_TRIG_INCR_READ_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_CTRL_TRIG_DATA_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_CTRL_TRIG_HIGH_PRIORITY_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_CTRL_TRIG_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_AL1_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH7_AL1_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_AL1_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH7_AL1_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_AL1_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH7_AL1_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_AL1_TRANS_COUNT_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH7_AL1_TRANS_COUNT_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_AL2_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH7_AL2_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_AL2_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH7_AL2_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_AL2_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH7_AL2_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_AL2_WRITE_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH7_AL2_WRITE_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_AL3_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH7_AL3_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_AL3_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH7_AL3_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_AL3_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH7_AL3_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH7_AL3_READ_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH7_AL3_READ_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_CTRL_TRIG_AHB_ERROR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH8_CTRL_TRIG_READ_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH8_CTRL_TRIG_WRITE_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH8_CTRL_TRIG_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH8_CTRL_TRIG_SNIFF_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_CTRL_TRIG_BSWAP_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_CTRL_TRIG_IRQ_QUIET_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_CTRL_TRIG_TREQ_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_CTRL_TRIG_CHAIN_TO_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_CTRL_TRIG_RING_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_CTRL_TRIG_RING_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_CTRL_TRIG_INCR_WRITE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_CTRL_TRIG_INCR_READ_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_CTRL_TRIG_DATA_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_CTRL_TRIG_HIGH_PRIORITY_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_CTRL_TRIG_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_AL1_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH8_AL1_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_AL1_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH8_AL1_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_AL1_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH8_AL1_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_AL1_TRANS_COUNT_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH8_AL1_TRANS_COUNT_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_AL2_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH8_AL2_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_AL2_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH8_AL2_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_AL2_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH8_AL2_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_AL2_WRITE_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH8_AL2_WRITE_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_AL3_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH8_AL3_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_AL3_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH8_AL3_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_AL3_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH8_AL3_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH8_AL3_READ_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH8_AL3_READ_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_CTRL_TRIG_AHB_ERROR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH9_CTRL_TRIG_READ_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH9_CTRL_TRIG_WRITE_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH9_CTRL_TRIG_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH9_CTRL_TRIG_SNIFF_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_CTRL_TRIG_BSWAP_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_CTRL_TRIG_IRQ_QUIET_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_CTRL_TRIG_TREQ_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_CTRL_TRIG_CHAIN_TO_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_CTRL_TRIG_RING_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_CTRL_TRIG_RING_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_CTRL_TRIG_INCR_WRITE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_CTRL_TRIG_INCR_READ_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_CTRL_TRIG_DATA_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_CTRL_TRIG_HIGH_PRIORITY_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_CTRL_TRIG_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_AL1_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH9_AL1_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_AL1_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH9_AL1_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_AL1_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH9_AL1_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_AL1_TRANS_COUNT_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH9_AL1_TRANS_COUNT_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_AL2_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH9_AL2_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_AL2_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH9_AL2_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_AL2_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH9_AL2_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_AL2_WRITE_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH9_AL2_WRITE_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_AL3_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH9_AL3_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_AL3_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH9_AL3_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_AL3_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH9_AL3_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH9_AL3_READ_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH9_AL3_READ_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_CTRL_TRIG_AHB_ERROR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH10_CTRL_TRIG_READ_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH10_CTRL_TRIG_WRITE_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH10_CTRL_TRIG_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH10_CTRL_TRIG_SNIFF_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_CTRL_TRIG_BSWAP_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_CTRL_TRIG_IRQ_QUIET_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_CTRL_TRIG_TREQ_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_CTRL_TRIG_CHAIN_TO_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_CTRL_TRIG_RING_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_CTRL_TRIG_RING_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_CTRL_TRIG_INCR_WRITE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_CTRL_TRIG_INCR_READ_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_CTRL_TRIG_DATA_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_CTRL_TRIG_HIGH_PRIORITY_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_CTRL_TRIG_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_AL1_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH10_AL1_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_AL1_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH10_AL1_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_AL1_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH10_AL1_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_AL1_TRANS_COUNT_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH10_AL1_TRANS_COUNT_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_AL2_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH10_AL2_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_AL2_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH10_AL2_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_AL2_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH10_AL2_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_AL2_WRITE_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH10_AL2_WRITE_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_AL3_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH10_AL3_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_AL3_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH10_AL3_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_AL3_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH10_AL3_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH10_AL3_READ_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH10_AL3_READ_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_CTRL_TRIG_AHB_ERROR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH11_CTRL_TRIG_READ_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH11_CTRL_TRIG_WRITE_ERROR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH11_CTRL_TRIG_BUSY_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH11_CTRL_TRIG_SNIFF_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_CTRL_TRIG_BSWAP_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_CTRL_TRIG_IRQ_QUIET_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_CTRL_TRIG_TREQ_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_CTRL_TRIG_CHAIN_TO_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_CTRL_TRIG_RING_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_CTRL_TRIG_RING_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_CTRL_TRIG_INCR_WRITE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_CTRL_TRIG_INCR_READ_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_CTRL_TRIG_DATA_SIZE_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_CTRL_TRIG_HIGH_PRIORITY_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_CTRL_TRIG_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_AL1_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH11_AL1_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_AL1_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH11_AL1_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_AL1_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH11_AL1_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_AL1_TRANS_COUNT_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH11_AL1_TRANS_COUNT_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_AL2_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH11_AL2_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_AL2_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH11_AL2_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_AL2_READ_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH11_AL2_READ_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_AL2_WRITE_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH11_AL2_WRITE_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_AL3_CTRL_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH11_AL3_CTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_AL3_WRITE_ADDR_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH11_AL3_WRITE_ADDR_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_AL3_TRANS_COUNT_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH11_AL3_TRANS_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_CH11_AL3_READ_ADDR_TRIG_RESET: &[u8; 2] = b"-\0";
pub const DMA_CH11_AL3_READ_ADDR_TRIG_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_INTR_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_INTE0_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_INTF0_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_INTS0_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_INTE1_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_INTF1_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_INTS1_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_TIMER0_X_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_TIMER0_Y_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_TIMER1_X_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_TIMER1_Y_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_TIMER2_X_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_TIMER2_Y_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_TIMER3_X_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_TIMER3_Y_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_MULTI_CHAN_TRIGGER_ACCESS: &[u8; 3] = b"SC\0";
pub const DMA_SNIFF_CTRL_OUT_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_SNIFF_CTRL_OUT_REV_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_SNIFF_CTRL_BSWAP_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_SNIFF_CTRL_CALC_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_SNIFF_CTRL_DMACH_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_SNIFF_CTRL_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_SNIFF_DATA_ACCESS: &[u8; 3] = b"RW\0";
pub const DMA_FIFO_LEVELS_RAF_LVL_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_FIFO_LEVELS_WAF_LVL_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_FIFO_LEVELS_TDF_LVL_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CHAN_ABORT_ACCESS: &[u8; 3] = b"SC\0";
pub const DMA_N_CHANNELS_RESET: &[u8; 2] = b"-\0";
pub const DMA_N_CHANNELS_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH0_DBG_CTDREQ_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH0_DBG_TCR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH1_DBG_CTDREQ_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH1_DBG_TCR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH2_DBG_CTDREQ_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH2_DBG_TCR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH3_DBG_CTDREQ_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH3_DBG_TCR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH4_DBG_CTDREQ_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH4_DBG_TCR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH5_DBG_CTDREQ_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH5_DBG_TCR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH6_DBG_CTDREQ_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH6_DBG_TCR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH7_DBG_CTDREQ_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH7_DBG_TCR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH8_DBG_CTDREQ_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH8_DBG_TCR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH9_DBG_CTDREQ_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH9_DBG_TCR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH10_DBG_CTDREQ_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH10_DBG_TCR_ACCESS: &[u8; 3] = b"RO\0";
pub const DMA_CH11_DBG_CTDREQ_ACCESS: &[u8; 3] = b"WC\0";
pub const DMA_CH11_DBG_TCR_ACCESS: &[u8; 3] = b"RO\0";
pub const PARAM_ASSERTIONS_ENABLED_DMA: u32 = 0;
pub const PARAM_ASSERTIONS_ENABLED_INTERP: u32 = 0;
pub const PIO_CTRL_CLKDIV_RESTART_ACCESS: &[u8; 3] = b"SC\0";
pub const PIO_CTRL_SM_RESTART_ACCESS: &[u8; 3] = b"SC\0";
pub const PIO_CTRL_SM_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_FSTAT_TXEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_FSTAT_TXFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_FSTAT_RXEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_FSTAT_RXFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_FDEBUG_TXSTALL_ACCESS: &[u8; 3] = b"WC\0";
pub const PIO_FDEBUG_TXOVER_ACCESS: &[u8; 3] = b"WC\0";
pub const PIO_FDEBUG_RXUNDER_ACCESS: &[u8; 3] = b"WC\0";
pub const PIO_FDEBUG_RXSTALL_ACCESS: &[u8; 3] = b"WC\0";
pub const PIO_FLEVEL_RX3_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_FLEVEL_TX3_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_FLEVEL_RX2_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_FLEVEL_TX2_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_FLEVEL_RX1_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_FLEVEL_TX1_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_FLEVEL_RX0_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_FLEVEL_TX0_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_TXF0_ACCESS: &[u8; 3] = b"WF\0";
pub const PIO_TXF1_ACCESS: &[u8; 3] = b"WF\0";
pub const PIO_TXF2_ACCESS: &[u8; 3] = b"WF\0";
pub const PIO_TXF3_ACCESS: &[u8; 3] = b"WF\0";
pub const PIO_RXF0_RESET: &[u8; 2] = b"-\0";
pub const PIO_RXF0_ACCESS: &[u8; 3] = b"RF\0";
pub const PIO_RXF1_RESET: &[u8; 2] = b"-\0";
pub const PIO_RXF1_ACCESS: &[u8; 3] = b"RF\0";
pub const PIO_RXF2_RESET: &[u8; 2] = b"-\0";
pub const PIO_RXF2_ACCESS: &[u8; 3] = b"RF\0";
pub const PIO_RXF3_RESET: &[u8; 2] = b"-\0";
pub const PIO_RXF3_ACCESS: &[u8; 3] = b"RF\0";
pub const PIO_IRQ_ACCESS: &[u8; 3] = b"WC\0";
pub const PIO_IRQ_FORCE_ACCESS: &[u8; 3] = b"WF\0";
pub const PIO_INPUT_SYNC_BYPASS_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_DBG_PADOUT_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_DBG_PADOE_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_DBG_CFGINFO_IMEM_SIZE_RESET: &[u8; 2] = b"-\0";
pub const PIO_DBG_CFGINFO_IMEM_SIZE_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_DBG_CFGINFO_SM_COUNT_RESET: &[u8; 2] = b"-\0";
pub const PIO_DBG_CFGINFO_SM_COUNT_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_DBG_CFGINFO_FIFO_DEPTH_RESET: &[u8; 2] = b"-\0";
pub const PIO_DBG_CFGINFO_FIFO_DEPTH_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_INSTR_MEM0_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM1_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM2_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM3_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM4_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM5_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM6_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM7_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM8_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM9_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM10_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM11_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM12_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM13_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM14_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM15_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM16_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM17_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM18_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM19_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM20_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM21_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM22_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM23_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM24_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM25_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM26_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM27_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM28_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM29_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM30_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_INSTR_MEM31_ACCESS: &[u8; 3] = b"WO\0";
pub const PIO_SM0_CLKDIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_CLKDIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_EXECCTRL_EXEC_STALLED_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_SM0_EXECCTRL_SIDE_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_EXECCTRL_SIDE_PINDIR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_EXECCTRL_JMP_PIN_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_EXECCTRL_OUT_EN_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_EXECCTRL_INLINE_OUT_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_EXECCTRL_OUT_STICKY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_EXECCTRL_WRAP_TOP_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_EXECCTRL_WRAP_BOTTOM_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_EXECCTRL_STATUS_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_EXECCTRL_STATUS_N_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_SHIFTCTRL_FJOIN_RX_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_SHIFTCTRL_FJOIN_TX_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_SHIFTCTRL_PULL_THRESH_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_SHIFTCTRL_PUSH_THRESH_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_SHIFTCTRL_OUT_SHIFTDIR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_SHIFTCTRL_IN_SHIFTDIR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_SHIFTCTRL_AUTOPULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_SHIFTCTRL_AUTOPUSH_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_ADDR_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_SM0_INSTR_RESET: &[u8; 2] = b"-\0";
pub const PIO_SM0_INSTR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_PINCTRL_SIDESET_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_PINCTRL_SET_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_PINCTRL_OUT_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_PINCTRL_IN_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_PINCTRL_SIDESET_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_PINCTRL_SET_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM0_PINCTRL_OUT_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_CLKDIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_CLKDIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_EXECCTRL_EXEC_STALLED_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_SM1_EXECCTRL_SIDE_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_EXECCTRL_SIDE_PINDIR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_EXECCTRL_JMP_PIN_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_EXECCTRL_OUT_EN_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_EXECCTRL_INLINE_OUT_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_EXECCTRL_OUT_STICKY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_EXECCTRL_WRAP_TOP_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_EXECCTRL_WRAP_BOTTOM_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_EXECCTRL_STATUS_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_EXECCTRL_STATUS_N_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_SHIFTCTRL_FJOIN_RX_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_SHIFTCTRL_FJOIN_TX_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_SHIFTCTRL_PULL_THRESH_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_SHIFTCTRL_PUSH_THRESH_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_SHIFTCTRL_OUT_SHIFTDIR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_SHIFTCTRL_IN_SHIFTDIR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_SHIFTCTRL_AUTOPULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_SHIFTCTRL_AUTOPUSH_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_ADDR_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_SM1_INSTR_RESET: &[u8; 2] = b"-\0";
pub const PIO_SM1_INSTR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_PINCTRL_SIDESET_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_PINCTRL_SET_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_PINCTRL_OUT_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_PINCTRL_IN_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_PINCTRL_SIDESET_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_PINCTRL_SET_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM1_PINCTRL_OUT_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_CLKDIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_CLKDIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_EXECCTRL_EXEC_STALLED_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_SM2_EXECCTRL_SIDE_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_EXECCTRL_SIDE_PINDIR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_EXECCTRL_JMP_PIN_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_EXECCTRL_OUT_EN_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_EXECCTRL_INLINE_OUT_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_EXECCTRL_OUT_STICKY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_EXECCTRL_WRAP_TOP_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_EXECCTRL_WRAP_BOTTOM_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_EXECCTRL_STATUS_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_EXECCTRL_STATUS_N_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_SHIFTCTRL_FJOIN_RX_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_SHIFTCTRL_FJOIN_TX_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_SHIFTCTRL_PULL_THRESH_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_SHIFTCTRL_PUSH_THRESH_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_SHIFTCTRL_OUT_SHIFTDIR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_SHIFTCTRL_IN_SHIFTDIR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_SHIFTCTRL_AUTOPULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_SHIFTCTRL_AUTOPUSH_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_ADDR_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_SM2_INSTR_RESET: &[u8; 2] = b"-\0";
pub const PIO_SM2_INSTR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_PINCTRL_SIDESET_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_PINCTRL_SET_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_PINCTRL_OUT_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_PINCTRL_IN_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_PINCTRL_SIDESET_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_PINCTRL_SET_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM2_PINCTRL_OUT_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_CLKDIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_CLKDIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_EXECCTRL_EXEC_STALLED_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_SM3_EXECCTRL_SIDE_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_EXECCTRL_SIDE_PINDIR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_EXECCTRL_JMP_PIN_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_EXECCTRL_OUT_EN_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_EXECCTRL_INLINE_OUT_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_EXECCTRL_OUT_STICKY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_EXECCTRL_WRAP_TOP_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_EXECCTRL_WRAP_BOTTOM_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_EXECCTRL_STATUS_SEL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_EXECCTRL_STATUS_N_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_SHIFTCTRL_FJOIN_RX_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_SHIFTCTRL_FJOIN_TX_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_SHIFTCTRL_PULL_THRESH_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_SHIFTCTRL_PUSH_THRESH_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_SHIFTCTRL_OUT_SHIFTDIR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_SHIFTCTRL_IN_SHIFTDIR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_SHIFTCTRL_AUTOPULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_SHIFTCTRL_AUTOPUSH_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_ADDR_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_SM3_INSTR_RESET: &[u8; 2] = b"-\0";
pub const PIO_SM3_INSTR_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_PINCTRL_SIDESET_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_PINCTRL_SET_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_PINCTRL_OUT_COUNT_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_PINCTRL_IN_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_PINCTRL_SIDESET_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_PINCTRL_SET_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_SM3_PINCTRL_OUT_BASE_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_INTR_SM3_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_INTR_SM2_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_INTR_SM1_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_INTR_SM0_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_INTR_SM3_TXNFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_INTR_SM2_TXNFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_INTR_SM1_TXNFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_INTR_SM0_TXNFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_INTR_SM3_RXNEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_INTR_SM2_RXNEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_INTR_SM1_RXNEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_INTR_SM0_RXNEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ0_INTE_SM3_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTE_SM2_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTE_SM1_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTE_SM0_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTE_SM3_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTE_SM2_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTE_SM1_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTE_SM0_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTE_SM3_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTE_SM2_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTE_SM1_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTE_SM0_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTF_SM3_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTF_SM2_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTF_SM1_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTF_SM0_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTF_SM3_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTF_SM2_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTF_SM1_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTF_SM0_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTF_SM3_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTF_SM2_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTF_SM1_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTF_SM0_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ0_INTS_SM3_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ0_INTS_SM2_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ0_INTS_SM1_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ0_INTS_SM0_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ0_INTS_SM3_TXNFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ0_INTS_SM2_TXNFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ0_INTS_SM1_TXNFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ0_INTS_SM0_TXNFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ0_INTS_SM3_RXNEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ0_INTS_SM2_RXNEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ0_INTS_SM1_RXNEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ0_INTS_SM0_RXNEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ1_INTE_SM3_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTE_SM2_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTE_SM1_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTE_SM0_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTE_SM3_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTE_SM2_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTE_SM1_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTE_SM0_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTE_SM3_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTE_SM2_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTE_SM1_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTE_SM0_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTF_SM3_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTF_SM2_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTF_SM1_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTF_SM0_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTF_SM3_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTF_SM2_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTF_SM1_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTF_SM0_TXNFULL_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTF_SM3_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTF_SM2_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTF_SM1_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTF_SM0_RXNEMPTY_ACCESS: &[u8; 3] = b"RW\0";
pub const PIO_IRQ1_INTS_SM3_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ1_INTS_SM2_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ1_INTS_SM1_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ1_INTS_SM0_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ1_INTS_SM3_TXNFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ1_INTS_SM2_TXNFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ1_INTS_SM1_TXNFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ1_INTS_SM0_TXNFULL_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ1_INTS_SM3_RXNEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ1_INTS_SM2_RXNEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ1_INTS_SM1_RXNEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PIO_IRQ1_INTS_SM0_RXNEMPTY_ACCESS: &[u8; 3] = b"RO\0";
pub const PARAM_ASSERTIONS_ENABLED_PIO_INSTRUCTIONS: u32 = 0;
pub const _PIO_INVALID_IN_SRC: u32 = 8;
pub const _PIO_INVALID_OUT_DEST: u32 = 16;
pub const _PIO_INVALID_SET_DEST: u32 = 32;
pub const _PIO_INVALID_MOV_SRC: u32 = 64;
pub const _PIO_INVALID_MOV_DEST: u32 = 128;
pub const PARAM_ASSERTIONS_ENABLED_PIO: u32 = 0;
pub const PWM_CH0_CSR_PH_ADV_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH0_CSR_PH_RET_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH0_CSR_DIVMODE_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH0_CSR_B_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH0_CSR_A_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH0_CSR_PH_CORRECT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH0_CSR_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH0_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH0_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH0_CTR_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH0_CC_B_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH0_CC_A_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH0_TOP_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH1_CSR_PH_ADV_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH1_CSR_PH_RET_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH1_CSR_DIVMODE_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH1_CSR_B_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH1_CSR_A_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH1_CSR_PH_CORRECT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH1_CSR_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH1_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH1_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH1_CTR_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH1_CC_B_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH1_CC_A_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH1_TOP_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH2_CSR_PH_ADV_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH2_CSR_PH_RET_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH2_CSR_DIVMODE_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH2_CSR_B_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH2_CSR_A_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH2_CSR_PH_CORRECT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH2_CSR_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH2_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH2_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH2_CTR_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH2_CC_B_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH2_CC_A_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH2_TOP_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH3_CSR_PH_ADV_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH3_CSR_PH_RET_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH3_CSR_DIVMODE_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH3_CSR_B_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH3_CSR_A_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH3_CSR_PH_CORRECT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH3_CSR_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH3_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH3_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH3_CTR_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH3_CC_B_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH3_CC_A_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH3_TOP_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH4_CSR_PH_ADV_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH4_CSR_PH_RET_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH4_CSR_DIVMODE_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH4_CSR_B_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH4_CSR_A_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH4_CSR_PH_CORRECT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH4_CSR_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH4_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH4_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH4_CTR_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH4_CC_B_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH4_CC_A_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH4_TOP_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH5_CSR_PH_ADV_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH5_CSR_PH_RET_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH5_CSR_DIVMODE_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH5_CSR_B_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH5_CSR_A_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH5_CSR_PH_CORRECT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH5_CSR_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH5_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH5_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH5_CTR_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH5_CC_B_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH5_CC_A_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH5_TOP_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH6_CSR_PH_ADV_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH6_CSR_PH_RET_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH6_CSR_DIVMODE_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH6_CSR_B_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH6_CSR_A_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH6_CSR_PH_CORRECT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH6_CSR_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH6_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH6_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH6_CTR_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH6_CC_B_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH6_CC_A_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH6_TOP_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH7_CSR_PH_ADV_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH7_CSR_PH_RET_ACCESS: &[u8; 3] = b"SC\0";
pub const PWM_CH7_CSR_DIVMODE_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH7_CSR_B_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH7_CSR_A_INV_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH7_CSR_PH_CORRECT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH7_CSR_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH7_DIV_INT_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH7_DIV_FRAC_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH7_CTR_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH7_CC_B_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH7_CC_A_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_CH7_TOP_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_EN_CH7_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_EN_CH6_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_EN_CH5_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_EN_CH4_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_EN_CH3_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_EN_CH2_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_EN_CH1_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_EN_CH0_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTR_CH7_ACCESS: &[u8; 3] = b"WC\0";
pub const PWM_INTR_CH6_ACCESS: &[u8; 3] = b"WC\0";
pub const PWM_INTR_CH5_ACCESS: &[u8; 3] = b"WC\0";
pub const PWM_INTR_CH4_ACCESS: &[u8; 3] = b"WC\0";
pub const PWM_INTR_CH3_ACCESS: &[u8; 3] = b"WC\0";
pub const PWM_INTR_CH2_ACCESS: &[u8; 3] = b"WC\0";
pub const PWM_INTR_CH1_ACCESS: &[u8; 3] = b"WC\0";
pub const PWM_INTR_CH0_ACCESS: &[u8; 3] = b"WC\0";
pub const PWM_INTE_CH7_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTE_CH6_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTE_CH5_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTE_CH4_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTE_CH3_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTE_CH2_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTE_CH1_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTE_CH0_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTF_CH7_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTF_CH6_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTF_CH5_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTF_CH4_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTF_CH3_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTF_CH2_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTF_CH1_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTF_CH0_ACCESS: &[u8; 3] = b"RW\0";
pub const PWM_INTS_CH7_ACCESS: &[u8; 3] = b"RO\0";
pub const PWM_INTS_CH6_ACCESS: &[u8; 3] = b"RO\0";
pub const PWM_INTS_CH5_ACCESS: &[u8; 3] = b"RO\0";
pub const PWM_INTS_CH4_ACCESS: &[u8; 3] = b"RO\0";
pub const PWM_INTS_CH3_ACCESS: &[u8; 3] = b"RO\0";
pub const PWM_INTS_CH2_ACCESS: &[u8; 3] = b"RO\0";
pub const PWM_INTS_CH1_ACCESS: &[u8; 3] = b"RO\0";
pub const PWM_INTS_CH0_ACCESS: &[u8; 3] = b"RO\0";
pub const PARAM_ASSERTIONS_ENABLED_PWM: u32 = 0;
pub const RESETS_RESET_USBCTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_UART1_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_UART0_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_TIMER_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_TBMAN_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_SYSINFO_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_SYSCFG_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_SPI1_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_SPI0_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_RTC_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_PWM_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_PLL_USB_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_PLL_SYS_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_PIO1_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_PIO0_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_PADS_QSPI_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_PADS_BANK0_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_JTAG_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_IO_QSPI_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_IO_BANK0_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_I2C1_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_I2C0_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_DMA_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_BUSCTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_ADC_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_USBCTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_UART1_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_UART0_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_TIMER_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_TBMAN_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_SYSINFO_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_SYSCFG_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_SPI1_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_SPI0_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_RTC_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_PWM_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_PLL_USB_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_PLL_SYS_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_PIO1_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_PIO0_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_PADS_QSPI_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_PADS_BANK0_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_JTAG_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_IO_QSPI_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_IO_BANK0_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_I2C1_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_I2C0_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_DMA_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_BUSCTRL_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_WDSEL_ADC_ACCESS: &[u8; 3] = b"RW\0";
pub const RESETS_RESET_DONE_USBCTRL_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_UART1_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_UART0_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_TIMER_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_TBMAN_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_SYSINFO_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_SYSCFG_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_SPI1_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_SPI0_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_RTC_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_PWM_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_PLL_USB_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_PLL_SYS_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_PIO1_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_PIO0_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_PADS_QSPI_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_PADS_BANK0_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_JTAG_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_IO_QSPI_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_IO_BANK0_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_I2C1_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_I2C0_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_DMA_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_BUSCTRL_ACCESS: &[u8; 3] = b"RO\0";
pub const RESETS_RESET_DONE_ADC_ACCESS: &[u8; 3] = b"RO\0";
pub const RTC_CLKDIV_M1_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_SETUP_0_YEAR_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_SETUP_0_MONTH_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_SETUP_0_DAY_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_SETUP_1_DOTW_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_SETUP_1_HOUR_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_SETUP_1_MIN_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_SETUP_1_SEC_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_CTRL_FORCE_NOTLEAPYEAR_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_CTRL_LOAD_ACCESS: &[u8; 3] = b"SC\0";
pub const RTC_CTRL_RTC_ACTIVE_RESET: &[u8; 2] = b"-\0";
pub const RTC_CTRL_RTC_ACTIVE_ACCESS: &[u8; 3] = b"RO\0";
pub const RTC_CTRL_RTC_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_0_MATCH_ACTIVE_RESET: &[u8; 2] = b"-\0";
pub const RTC_IRQ_SETUP_0_MATCH_ACTIVE_ACCESS: &[u8; 3] = b"RO\0";
pub const RTC_IRQ_SETUP_0_MATCH_ENA_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_0_YEAR_ENA_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_0_MONTH_ENA_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_0_DAY_ENA_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_0_YEAR_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_0_MONTH_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_0_DAY_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_1_DOTW_ENA_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_1_HOUR_ENA_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_1_MIN_ENA_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_1_SEC_ENA_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_1_DOTW_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_1_HOUR_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_1_MIN_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_IRQ_SETUP_1_SEC_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_RTC_1_YEAR_RESET: &[u8; 2] = b"-\0";
pub const RTC_RTC_1_YEAR_ACCESS: &[u8; 3] = b"RO\0";
pub const RTC_RTC_1_MONTH_RESET: &[u8; 2] = b"-\0";
pub const RTC_RTC_1_MONTH_ACCESS: &[u8; 3] = b"RO\0";
pub const RTC_RTC_1_DAY_RESET: &[u8; 2] = b"-\0";
pub const RTC_RTC_1_DAY_ACCESS: &[u8; 3] = b"RO\0";
pub const RTC_RTC_0_DOTW_RESET: &[u8; 2] = b"-\0";
pub const RTC_RTC_0_DOTW_ACCESS: &[u8; 3] = b"RF\0";
pub const RTC_RTC_0_HOUR_RESET: &[u8; 2] = b"-\0";
pub const RTC_RTC_0_HOUR_ACCESS: &[u8; 3] = b"RF\0";
pub const RTC_RTC_0_MIN_RESET: &[u8; 2] = b"-\0";
pub const RTC_RTC_0_MIN_ACCESS: &[u8; 3] = b"RF\0";
pub const RTC_RTC_0_SEC_RESET: &[u8; 2] = b"-\0";
pub const RTC_RTC_0_SEC_ACCESS: &[u8; 3] = b"RF\0";
pub const RTC_INTR_RTC_ACCESS: &[u8; 3] = b"RO\0";
pub const RTC_INTE_RTC_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_INTF_RTC_ACCESS: &[u8; 3] = b"RW\0";
pub const RTC_INTS_RTC_ACCESS: &[u8; 3] = b"RO\0";
pub const VREG_AND_CHIP_RESET_VREG_ROK_ACCESS: &[u8; 3] = b"RO\0";
pub const VREG_AND_CHIP_RESET_VREG_VSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const VREG_AND_CHIP_RESET_VREG_HIZ_ACCESS: &[u8; 3] = b"RW\0";
pub const VREG_AND_CHIP_RESET_VREG_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const VREG_AND_CHIP_RESET_BOD_VSEL_ACCESS: &[u8; 3] = b"RW\0";
pub const VREG_AND_CHIP_RESET_BOD_EN_ACCESS: &[u8; 3] = b"RW\0";
pub const VREG_AND_CHIP_RESET_CHIP_RESET_PSM_RESTART_FLAG_ACCESS: &[u8; 3] = b"WC\0";
pub const VREG_AND_CHIP_RESET_CHIP_RESET_HAD_PSM_RESTART_ACCESS: &[u8; 3] = b"RO\0";
pub const VREG_AND_CHIP_RESET_CHIP_RESET_HAD_RUN_ACCESS: &[u8; 3] = b"RO\0";
pub const VREG_AND_CHIP_RESET_CHIP_RESET_HAD_POR_ACCESS: &[u8; 3] = b"RO\0";
pub const WATCHDOG_CTRL_TRIGGER_ACCESS: &[u8; 3] = b"SC\0";
pub const WATCHDOG_CTRL_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const WATCHDOG_CTRL_PAUSE_DBG1_ACCESS: &[u8; 3] = b"RW\0";
pub const WATCHDOG_CTRL_PAUSE_DBG0_ACCESS: &[u8; 3] = b"RW\0";
pub const WATCHDOG_CTRL_PAUSE_JTAG_ACCESS: &[u8; 3] = b"RW\0";
pub const WATCHDOG_CTRL_TIME_ACCESS: &[u8; 3] = b"RO\0";
pub const WATCHDOG_LOAD_ACCESS: &[u8; 3] = b"WF\0";
pub const WATCHDOG_REASON_FORCE_ACCESS: &[u8; 3] = b"RO\0";
pub const WATCHDOG_REASON_TIMER_ACCESS: &[u8; 3] = b"RO\0";
pub const WATCHDOG_SCRATCH0_ACCESS: &[u8; 3] = b"RW\0";
pub const WATCHDOG_SCRATCH1_ACCESS: &[u8; 3] = b"RW\0";
pub const WATCHDOG_SCRATCH2_ACCESS: &[u8; 3] = b"RW\0";
pub const WATCHDOG_SCRATCH3_ACCESS: &[u8; 3] = b"RW\0";
pub const WATCHDOG_SCRATCH4_ACCESS: &[u8; 3] = b"RW\0";
pub const WATCHDOG_SCRATCH5_ACCESS: &[u8; 3] = b"RW\0";
pub const WATCHDOG_SCRATCH6_ACCESS: &[u8; 3] = b"RW\0";
pub const WATCHDOG_SCRATCH7_ACCESS: &[u8; 3] = b"RW\0";
pub const WATCHDOG_TICK_COUNT_RESET: &[u8; 2] = b"-\0";
pub const WATCHDOG_TICK_COUNT_ACCESS: &[u8; 3] = b"RO\0";
pub const WATCHDOG_TICK_RUNNING_RESET: &[u8; 2] = b"-\0";
pub const WATCHDOG_TICK_RUNNING_ACCESS: &[u8; 3] = b"RO\0";
pub const WATCHDOG_TICK_ENABLE_ACCESS: &[u8; 3] = b"RW\0";
pub const WATCHDOG_TICK_CYCLES_ACCESS: &[u8; 3] = b"RW\0";
pub type wchar_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __int_least8_t = ::core::ffi::c_schar;
pub type __uint_least8_t = ::core::ffi::c_uchar;
pub type __int_least16_t = ::core::ffi::c_short;
pub type __uint_least16_t = ::core::ffi::c_ushort;
pub type __int_least32_t = ::core::ffi::c_int;
pub type __uint_least32_t = ::core::ffi::c_uint;
pub type __int_least64_t = ::core::ffi::c_longlong;
pub type __uint_least64_t = ::core::ffi::c_ulonglong;
pub type __intmax_t = ::core::ffi::c_longlong;
pub type __uintmax_t = ::core::ffi::c_ulonglong;
pub type __intptr_t = ::core::ffi::c_int;
pub type __uintptr_t = ::core::ffi::c_uint;
pub type wint_t = ::core::ffi::c_int;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blksize_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
pub type __dev_t = ::core::ffi::c_short;
pub type __uid_t = ::core::ffi::c_ushort;
pub type __gid_t = ::core::ffi::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = ::core::ffi::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::core::ffi::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::core::ffi::c_long;
pub type _fpos_t = ::core::ffi::c_long;
pub type __size_t = ::core::ffi::c_uint;
pub type _ssize_t = ::core::ffi::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<wint_t>,
    pub __wchb: __BindgenUnionField<[::core::ffi::c_uchar; 4usize]>,
    pub bindgen_union_field: u32,
}
pub type _iconv_t = *mut ::core::ffi::c_void;
pub type __clock_t = ::core::ffi::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::core::ffi::c_ulong;
pub type __daddr_t = ::core::ffi::c_long;
pub type __timer_t = ::core::ffi::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::core::ffi::c_int;
pub type __nlink_t = ::core::ffi::c_ushort;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_ulong;
pub type __va_list = u32;
pub type __ULong = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::core::ffi::c_int,
    pub _maxwds: ::core::ffi::c_int,
    pub _sign: ::core::ffi::c_int,
    pub _wds: ::core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::core::ffi::c_int,
    pub __tm_min: ::core::ffi::c_int,
    pub __tm_hour: ::core::ffi::c_int,
    pub __tm_mday: ::core::ffi::c_int,
    pub __tm_mon: ::core::ffi::c_int,
    pub __tm_year: ::core::ffi::c_int,
    pub __tm_wday: ::core::ffi::c_int,
    pub __tm_yday: ::core::ffi::c_int,
    pub __tm_isdst: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut ::core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::core::ffi::c_uchar,
    pub _size: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::core::ffi::c_uchar,
    pub _r: ::core::ffi::c_int,
    pub _w: ::core::ffi::c_int,
    pub _flags: ::core::ffi::c_short,
    pub _file: ::core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::core::ffi::c_int,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *mut ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *const ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: _fpos_t,
            arg4: ::core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::core::ffi::c_uchar,
    pub _ur: ::core::ffi::c_int,
    pub _ubuf: [::core::ffi::c_uchar; 3usize],
    pub _nbuf: [::core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::core::ffi::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::core::ffi::c_int,
}
pub type __FILE = __sFILE;
extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::core::ffi::c_ushort; 3usize],
    pub _mult: [::core::ffi::c_ushort; 3usize],
    pub _add: ::core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent {
    pub _errno: ::core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::core::ffi::c_int,
    pub _emergency: [::core::ffi::c_char; 25usize],
    pub _locale: *mut __locale_t,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::core::ffi::c_int,
    pub _cvtbuf: *mut ::core::ffi::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1 {
    pub _reent: __BindgenUnionField<_reent__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 29usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _strtok_last: *mut ::core::ffi::c_char,
    pub _asctime_buf: [::core::ffi::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::core::ffi::c_int,
    pub _rand_next: ::core::ffi::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::core::ffi::c_char; 8usize],
    pub _signal_buf: [::core::ffi::c_char; 24usize],
    pub _getdate_err: ::core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::core::ffi::c_int,
    pub _getlocalename_l_buf: [::core::ffi::c_char; 32usize],
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _impure_data: _reent;
}
extern "C" {
    pub static mut __atexit: *mut _atexit;
}
extern "C" {
    pub static mut __atexit0: _atexit;
}
extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> ::core::ffi::c_int,
        >,
        arg3: *mut _glue,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo {
    pub arena: usize,
    pub ordblks: usize,
    pub smblks: usize,
    pub hblks: usize,
    pub hblkhd: usize,
    pub usmblks: usize,
    pub fsmblks: usize,
    pub uordblks: usize,
    pub fordblks: usize,
    pub keepcost: usize,
}
extern "C" {
    pub fn malloc(arg1: ::core::ffi::c_uint) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn realloc(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn calloc(arg1: ::core::ffi::c_uint, arg2: ::core::ffi::c_uint)
        -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memalign(
        arg1: ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _memalign_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mallinfo() -> mallinfo;
}
extern "C" {
    pub fn _mallinfo_r(arg1: *mut _reent) -> mallinfo;
}
extern "C" {
    pub fn malloc_stats();
}
extern "C" {
    pub fn _malloc_stats_r(arg1: *mut _reent);
}
extern "C" {
    pub fn mallopt(arg1: ::core::ffi::c_int, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mallopt_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn malloc_usable_size(arg1: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn _malloc_usable_size_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _valloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn pvalloc(arg1: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _pvalloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn malloc_trim(arg1: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _malloc_trim_r(arg1: *mut _reent, arg2: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __malloc_lock(arg1: *mut _reent);
}
extern "C" {
    pub fn __malloc_unlock(arg1: *mut _reent);
}
extern "C" {
    pub fn mstats(arg1: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn cfree(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn __assert(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_func(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: *const ::core::ffi::c_char,
    ) -> !;
}
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type int_fast16_t = ::core::ffi::c_short;
pub type uint_fast16_t = ::core::ffi::c_ushort;
pub type int_fast32_t = ::core::ffi::c_int;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type int_fast64_t = ::core::ffi::c_longlong;
pub type uint_fast64_t = ::core::ffi::c_ulonglong;
pub type uint = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct absolute_time_t {
    pub _private_us_since_boot: u64,
}
#[doc = " \\struct datetime_t\n  \\ingroup util_datetime\n  \\brief Structure containing date and time information\n\n    When setting an RTC alarm, set a field to -1 tells\n    the RTC to not match on this field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct datetime_t {
    #[doc = "< 0..4095"]
    pub year: i16,
    #[doc = "< 1..12, 1 is January"]
    pub month: i8,
    #[doc = "< 1..28,29,30,31 depending on month"]
    pub day: i8,
    #[doc = "< 0..6, 0 is Sunday"]
    pub dotw: i8,
    #[doc = "< 0..23"]
    pub hour: i8,
    #[doc = "< 0..59"]
    pub min: i8,
    #[doc = "< 0..59"]
    pub sec: i8,
}
extern "C" {
    #[doc = " \\brief Panics with the message \"Unsupported\"\n  \\ingroup pico_platform\n  \\see panic"]
    pub fn panic_unsupported() -> !;
}
extern "C" {
    #[doc = " \\brief Displays a panic message and halts execution\n  \\ingroup pico_platform\n\n An attempt is made to output the message to all registered STDOUT drivers\n after which this method executes a BKPT instruction.\n\n @param fmt format string (printf-like)\n @param ...  printf-like arguments"]
    pub fn panic(fmt: *const ::core::ffi::c_char, ...) -> !;
}
extern "C" {
    pub fn running_on_fpga() -> bool;
}
extern "C" {
    #[doc = " \\brief Returns the RP2040 chip revision number\n  \\ingroup pico_platform\n @return the RP2040 chip revision number (1 for B0/B1, 2 for B2)"]
    pub fn rp2040_chip_version() -> u8;
}
pub const PICO_OK: pico_error_codes = 0;
pub const PICO_ERROR_NONE: pico_error_codes = 0;
pub const PICO_ERROR_TIMEOUT: pico_error_codes = -1;
pub const PICO_ERROR_GENERIC: pico_error_codes = -2;
pub const PICO_ERROR_NO_DATA: pico_error_codes = -3;
pub const PICO_ERROR_NOT_PERMITTED: pico_error_codes = -4;
pub const PICO_ERROR_INVALID_ARG: pico_error_codes = -5;
pub const PICO_ERROR_IO: pico_error_codes = -6;
pub const PICO_ERROR_BADAUTH: pico_error_codes = -7;
pub const PICO_ERROR_CONNECT_FAILED: pico_error_codes = -8;
pub const PICO_ERROR_INSUFFICIENT_RESOURCES: pico_error_codes = -9;
#[doc = " \\brief Common return codes from pico_sdk methods that return a status\n \\ingroup pico_base"]
pub type pico_error_codes = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stdio_driver {
    _unused: [u8; 0],
}
pub type stdio_driver_t = stdio_driver;
extern "C" {
    #[doc = " \\brief Initialize all of the present standard stdio types that are linked into the binary.\n \\ingroup pico_stdio\n\n Call this method once you have set up your clocks to enable the stdio support for UART, USB\n and semihosting based on the presence of the respective libraries in the binary.\n\n When stdio_usb is configured, this method can be optionally made to block, waiting for a connection\n via the variables specified in \\ref stdio_usb_init (i.e. \\ref PICO_STDIO_USB_CONNECT_WAIT_TIMEOUT_MS)\n\n \\return true if at least one output was successfully initialized, false otherwise.\n \\see stdio_uart, stdio_usb, stdio_semihosting"]
    pub fn stdio_init_all() -> bool;
}
extern "C" {
    #[doc = " \\brief Flushes any buffered output.\n \\ingroup pico_stdio"]
    pub fn stdio_flush();
}
extern "C" {
    #[doc = " \\brief Return a character from stdin if there is one available within a timeout\n \\ingroup pico_stdio\n\n \\param timeout_us the timeout in microseconds, or 0 to not wait for a character if none available.\n \\return the character from 0-255 or PICO_ERROR_TIMEOUT if timeout occurs"]
    pub fn getchar_timeout_us(timeout_us: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief Adds or removes a driver from the list of active drivers used for input/output\n \\ingroup pico_stdio\n\n \\note this method should always be called on an initialized driver and is not re-entrant\n \\param driver the driver\n \\param enabled true to add, false to remove"]
    pub fn stdio_set_driver_enabled(driver: *mut stdio_driver_t, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Control limiting of output to a single driver\n \\ingroup pico_stdio\n\n \\note this method should always be called on an initialized driver\n\n \\param driver if non-null then output only that driver will be used for input/output (assuming it is in the list of enabled drivers).\n               if NULL then all enabled drivers will be used"]
    pub fn stdio_filter_driver(driver: *mut stdio_driver_t);
}
extern "C" {
    #[doc = " \\brief control conversion of line feeds to carriage return on transmissions\n \\ingroup pico_stdio\n\n \\note this method should always be called on an initialized driver\n\n \\param driver the driver\n \\param translate If true, convert line feeds to carriage return on transmissions"]
    pub fn stdio_set_translate_crlf(driver: *mut stdio_driver_t, translate: bool);
}
extern "C" {
    #[doc = " \\brief putchar variant that skips any CR/LF conversion if enabled\n \\ingroup pico_stdio"]
    pub fn putchar_raw(c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief puts variant that skips any CR/LF conversion if enabled\n \\ingroup pico_stdio"]
    pub fn puts_raw(s: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief get notified when there are input characters available\n \\ingroup pico_stdio\n\n \\param fn Callback function to be called when characters are available. Pass NULL to cancel any existing callback\n \\param param Pointer to pass to the callback"]
    pub fn stdio_set_chars_available_callback(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        param: *mut ::core::ffi::c_void,
    );
}
pub type io_rw_32 = u32;
pub type io_ro_32 = u32;
pub type io_wo_32 = u32;
pub type io_rw_16 = u16;
pub type io_ro_16 = u16;
pub type io_wo_16 = u16;
pub type io_rw_8 = u8;
pub type io_ro_8 = u8;
pub type io_wo_8 = u8;
pub type ioptr = *mut u8;
pub type const_ioptr = ioptr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_hw_t {
    pub timehw: io_wo_32,
    pub timelw: io_wo_32,
    pub timehr: io_ro_32,
    pub timelr: io_ro_32,
    pub alarm: [io_rw_32; 4usize],
    pub armed: io_rw_32,
    pub timerawh: io_ro_32,
    pub timerawl: io_ro_32,
    pub dbgpause: io_rw_32,
    pub pause: io_rw_32,
    pub intr: io_rw_32,
    pub inte: io_rw_32,
    pub intf: io_rw_32,
    pub ints: io_ro_32,
}
extern "C" {
    #[doc = " \\brief Return the current 64 bit timestamp value in microseconds\n  \\ingroup hardware_timer\n\n Returns the full 64 bits of the hardware timer. The \\ref pico_time and other functions rely on the fact that this\n value monotonically increases from power up. As such it is expected that this value counts upwards and never wraps\n (we apologize for introducing a potential year 5851444 bug).\n\n \\return the 64 bit timestamp"]
    pub fn time_us_64() -> u64;
}
extern "C" {
    #[doc = " \\brief Busy wait wasting cycles for the given (32 bit) number of microseconds\n  \\ingroup hardware_timer\n\n \\param delay_us delay amount in microseconds"]
    pub fn busy_wait_us_32(delay_us: u32);
}
extern "C" {
    #[doc = " \\brief Busy wait wasting cycles for the given (64 bit) number of microseconds\n  \\ingroup hardware_timer\n\n \\param delay_us delay amount in microseconds"]
    pub fn busy_wait_us(delay_us: u64);
}
extern "C" {
    #[doc = " \\brief Busy wait wasting cycles for the given number of milliseconds\n  \\ingroup hardware_timer\n\n \\param delay_ms delay amount in milliseconds"]
    pub fn busy_wait_ms(delay_ms: u32);
}
extern "C" {
    #[doc = " \\brief Busy wait wasting cycles until after the specified timestamp\n  \\ingroup hardware_timer\n\n \\param t Absolute time to wait until"]
    pub fn busy_wait_until(t: absolute_time_t);
}
#[doc = " Callback function type for hardware alarms\n  \\ingroup hardware_timer\n\n \\param alarm_num the hardware alarm number\n \\sa hardware_alarm_set_callback()"]
pub type hardware_alarm_callback_t = ::core::option::Option<unsafe extern "C" fn(alarm_num: uint)>;
extern "C" {
    #[doc = " \\brief cooperatively claim the use of this hardware alarm_num\n  \\ingroup hardware_timer\n\n This method hard asserts if the hardware alarm is currently claimed.\n\n \\param alarm_num the hardware alarm to claim\n \\sa hardware_claiming"]
    pub fn hardware_alarm_claim(alarm_num: uint);
}
extern "C" {
    #[doc = " \\brief cooperatively claim the use of this hardware alarm_num\n  \\ingroup hardware_timer\n\n This method attempts to claim an unused hardware alarm\n\n \\return alarm_num the hardware alarm claimed or -1 if requires was false, and none are available\n \\sa hardware_claiming"]
    pub fn hardware_alarm_claim_unused(required: bool) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief cooperatively release the claim on use of this hardware alarm_num\n  \\ingroup hardware_timer\n\n \\param alarm_num the hardware alarm to unclaim\n \\sa hardware_claiming"]
    pub fn hardware_alarm_unclaim(alarm_num: uint);
}
extern "C" {
    #[doc = " \\brief Determine if a hardware alarm has been claimed\n  \\ingroup hardware_timer\n\n \\param alarm_num the hardware alarm number\n \\return true if claimed, false otherwise\n \\see hardware_alarm_claim"]
    pub fn hardware_alarm_is_claimed(alarm_num: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Enable/Disable a callback for a hardware timer on this core\n  \\ingroup hardware_timer\n\n This method enables/disables the alarm IRQ for the specified hardware alarm on the\n calling core, and set the specified callback to be associated with that alarm.\n\n This callback will be used for the timeout set via hardware_alarm_set_target\n\n \\note This will install the handler on the current core if the IRQ handler isn't already set.\n Therefore the user has the opportunity to call this up from the core of their choice\n\n \\param alarm_num the hardware alarm number\n \\param callback the callback to install, or NULL to unset\n\n \\sa hardware_alarm_set_target()"]
    pub fn hardware_alarm_set_callback(alarm_num: uint, callback: hardware_alarm_callback_t);
}
extern "C" {
    #[doc = " \\brief Set the current target for the specified hardware alarm\n \\ingroup hardware_timer\n\n This will replace any existing target\n\n @param alarm_num the hardware alarm number\n @param t the target timestamp\n @return true if the target was \"missed\"; i.e. it was in the past, or occurred before a future hardware timeout could be set"]
    pub fn hardware_alarm_set_target(alarm_num: uint, t: absolute_time_t) -> bool;
}
extern "C" {
    #[doc = " \\brief Cancel an existing target (if any) for a given hardware_alarm\n \\ingroup hardware_timer\n\n @param alarm_num the hardware alarm number"]
    pub fn hardware_alarm_cancel(alarm_num: uint);
}
extern "C" {
    #[doc = " \\brief Force and IRQ for a specific hardware alarm\n \\ingroup hardware_timer\n\n This method will forcibly make sure the current alarm callback (if present) for the hardware\n alarm is called from an IRQ context after this call. If an actual callback is due at the same\n time then the callback may only be called once.\n\n Calling this method does not otherwise interfere with regular callback operations.\n\n @param alarm_num the hardware alarm number"]
    pub fn hardware_alarm_force_irq(alarm_num: uint);
}
extern "C" {
    #[doc = " \\brief The timestamp representing the end of time; this is actually not the maximum possible\n timestamp, but is set to 0x7fffffff_ffffffff microseconds to avoid sign overflows with time\n arithmetic. This is almost 300,000 years, so should be sufficient.\n \\ingroup timestamp"]
    pub static at_the_end_of_time: absolute_time_t;
}
extern "C" {
    #[doc = " \\brief The timestamp representing a null timestamp\n \\ingroup timestamp"]
    pub static nil_time: absolute_time_t;
}
extern "C" {
    #[doc = " \\brief Wait until after the given timestamp to return\n \\ingroup sleep\n\n \\note  This method attempts to perform a lower power (WFE) sleep\n\n \\param target the time after which to return\n \\sa sleep_us()\n \\sa busy_wait_until()"]
    pub fn sleep_until(target: absolute_time_t);
}
extern "C" {
    #[doc = " \\brief Wait for the given number of microseconds before returning\n \\ingroup sleep\n\n \\note This method attempts to perform a lower power (WFE) sleep\n\n \\param us the number of microseconds to sleep\n \\sa busy_wait_us()"]
    pub fn sleep_us(us: u64);
}
extern "C" {
    #[doc = " \\brief Wait for the given number of milliseconds before returning\n \\ingroup sleep\n\n \\note This method attempts to perform a lower power sleep (using WFE) as much as possible.\n\n \\param ms the number of milliseconds to sleep"]
    pub fn sleep_ms(ms: u32);
}
extern "C" {
    #[doc = " \\brief Helper method for blocking on a timeout\n \\ingroup sleep\n\n This method will return in response to an event (as per __wfe) or\n when the target time is reached, or at any point before.\n\n This method can be used to implement a lower power polling loop waiting on\n some condition signalled by an event (__sev()).\n\n This is called \\a best_effort because under certain circumstances (notably the default timer pool\n being disabled or full) the best effort is simply to return immediately without a __wfe, thus turning the calling\n code into a busy wait.\n\n Example usage:\n ```c\n bool my_function_with_timeout_us(uint64_t timeout_us) {\n     absolute_time_t timeout_time = make_timeout_time_us(timeout_us);\n     do {\n         // each time round the loop, we check to see if the condition\n         // we are waiting on has happened\n         if (my_check_done()) {\n             // do something\n             return true;\n         }\n         // will try to sleep until timeout or the next processor event\n     } while (!best_effort_wfe_or_timeout(timeout_time));\n     return false; // timed out\n }\n ```\n\n @param timeout_timestamp the timeout time\n @return true if the target time is reached, false otherwise"]
    pub fn best_effort_wfe_or_timeout(timeout_timestamp: absolute_time_t) -> bool;
}
#[doc = " \\brief The identifier for an alarm\n\n \\note this identifier is signed because -1 is used as an error condition when creating alarms\n\n \\note alarm ids may be reused, however for convenience the implementation makes an attempt to defer\n reusing as long as possible. You should certainly expect it to be hundreds of ids before one is\n reused, although in most cases it is more. Nonetheless care must still be taken when cancelling\n alarms or other functionality based on alarms when the alarm may have expired, as eventually\n the alarm id may be reused for another alarm.\n\n \\ingroup alarm"]
pub type alarm_id_t = i32;
#[doc = " \\brief User alarm callback\n \\ingroup alarm\n \\param id the alarm_id as returned when the alarm was added\n \\param user_data the user data passed when the alarm was added\n \\return <0 to reschedule the same alarm this many us from the time the alarm was previously scheduled to fire\n \\return >0 to reschedule the same alarm this many us from the time this method returns\n \\return 0 to not reschedule the alarm"]
pub type alarm_callback_t = ::core::option::Option<
    unsafe extern "C" fn(id: alarm_id_t, user_data: *mut ::core::ffi::c_void) -> i64,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alarm_pool {
    _unused: [u8; 0],
}
pub type alarm_pool_t = alarm_pool;
extern "C" {
    #[doc = " \\brief Create the default alarm pool (if not already created or disabled)\n \\ingroup alarm"]
    pub fn alarm_pool_init_default();
}
extern "C" {
    #[doc = " \\brief The default alarm pool used when alarms are added without specifying an alarm pool,\n        and also used by the SDK to support lower power sleeps and timeouts.\n\n \\ingroup alarm\n \\sa #PICO_TIME_DEFAULT_ALARM_POOL_HARDWARE_ALARM_NUM"]
    pub fn alarm_pool_get_default() -> *mut alarm_pool_t;
}
extern "C" {
    #[doc = " \\brief Create an alarm pool\n\n The alarm pool will call callbacks from an alarm IRQ Handler on the core of this function is called from.\n\n In many situations there is never any need for anything other than the default alarm pool, however you\n might want to create another if you want alarm callbacks on core 1 or require alarm pools of\n different priority (IRQ priority based preemption of callbacks)\n\n \\note This method will hard assert if the hardware alarm is already claimed.\n\n \\ingroup alarm\n \\param hardware_alarm_num the hardware alarm to use to back this pool\n \\param max_timers the maximum number of timers\n        \\note For implementation reasons this is limited to PICO_PHEAP_MAX_ENTRIES which defaults to 255\n \\sa alarm_pool_get_default()\n \\sa hardware_claiming"]
    pub fn alarm_pool_create(hardware_alarm_num: uint, max_timers: uint) -> *mut alarm_pool_t;
}
extern "C" {
    #[doc = " \\brief Create an alarm pool, claiming an used hardware alarm to back it.\n\n The alarm pool will call callbacks from an alarm IRQ Handler on the core of this function is called from.\n\n In many situations there is never any need for anything other than the default alarm pool, however you\n might want to create another if you want alarm callbacks on core 1 or require alarm pools of\n different priority (IRQ priority based preemption of callbacks)\n\n \\note This method will hard assert if the there is no free hardware to claim.\n\n \\ingroup alarm\n \\param max_timers the maximum number of timers\n        \\note For implementation reasons this is limited to PICO_PHEAP_MAX_ENTRIES which defaults to 255\n \\sa alarm_pool_get_default()\n \\sa hardware_claiming"]
    pub fn alarm_pool_create_with_unused_hardware_alarm(max_timers: uint) -> *mut alarm_pool_t;
}
extern "C" {
    #[doc = " \\brief Return the hardware alarm used by an alarm pool\n \\ingroup alarm\n \\param pool the pool\n \\return the hardware alarm used by the pool"]
    pub fn alarm_pool_hardware_alarm_num(pool: *mut alarm_pool_t) -> uint;
}
extern "C" {
    #[doc = " \\brief Return the core number the alarm pool was initialized on (and hence callbacks are called on)\n \\ingroup alarm\n \\param pool the pool\n \\return the core used by the pool"]
    pub fn alarm_pool_core_num(pool: *mut alarm_pool_t) -> uint;
}
extern "C" {
    #[doc = " \\brief Destroy the alarm pool, cancelling all alarms and freeing up the underlying hardware alarm\n \\ingroup alarm\n \\param pool the pool"]
    pub fn alarm_pool_destroy(pool: *mut alarm_pool_t);
}
extern "C" {
    #[doc = " \\brief Add an alarm callback to be called at a specific time\n \\ingroup alarm\n\n Generally the callback is called as soon as possible after the time specified from an IRQ handler\n on the core the alarm pool was created on. If the callback is in the past or happens before\n the alarm setup could be completed, then this method will optionally call the callback itself\n and then return a return code to indicate that the target time has passed.\n\n \\note It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.\n\n @param pool the alarm pool to use for scheduling the callback (this determines which hardware alarm is used, and which core calls the callback)\n @param time the timestamp when (after which) the callback should fire\n @param callback the callback function\n @param user_data user data to pass to the callback function\n @param fire_if_past if true, and the alarm time falls before or during this call before the alarm can be set,\n                     then the callback should be called during (by) this function instead\n @return >0 the alarm id for an active (at the time of return) alarm\n @return 0 if the alarm time passed before or during the call AND there is no active alarm to return the id of.\n           The latter can either happen because fire_if_past was false (i.e. no timer was ever created),\n           or if the callback <i>was</i> called during this method but the callback cancelled itself by returning 0\n @return -1 if there were no alarm slots available"]
    pub fn alarm_pool_add_alarm_at(
        pool: *mut alarm_pool_t,
        time: absolute_time_t,
        callback: alarm_callback_t,
        user_data: *mut ::core::ffi::c_void,
        fire_if_past: bool,
    ) -> alarm_id_t;
}
extern "C" {
    #[doc = " \\brief Add an alarm callback to be called at or after a specific time\n \\ingroup alarm\n\n The callback is called as soon as possible after the time specified from an IRQ handler\n on the core the alarm pool was created on. Unlike \\ref alarm_pool_add_alarm_at, this method\n guarantees to call the callback from that core even if the time is during this method call or in the past.\n\n \\note It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.\n\n @param pool the alarm pool to use for scheduling the callback (this determines which hardware alarm is used, and which core calls the callback)\n @param time the timestamp when (after which) the callback should fire\n @param callback the callback function\n @param user_data user data to pass to the callback function\n @return >0 the alarm id for an active (at the time of return) alarm\n @return -1 if there were no alarm slots available"]
    pub fn alarm_pool_add_alarm_at_force_in_context(
        pool: *mut alarm_pool_t,
        time: absolute_time_t,
        callback: alarm_callback_t,
        user_data: *mut ::core::ffi::c_void,
    ) -> alarm_id_t;
}
extern "C" {
    #[doc = " \\brief Cancel an alarm\n \\ingroup alarm\n \\param pool the alarm_pool containing the alarm\n \\param alarm_id the alarm\n \\return true if the alarm was cancelled, false if it didn't exist\n \\sa alarm_id_t for a note on reuse of IDs"]
    pub fn alarm_pool_cancel_alarm(pool: *mut alarm_pool_t, alarm_id: alarm_id_t) -> bool;
}
#[doc = " \\defgroup repeating_timer repeating_timer\n \\ingroup pico_time\n \\brief Repeating Timer functions for simple scheduling of repeated execution\n\n \\note The regular \\a alarm_ functionality can be used to make repeating alarms (by return non zero from the callback),\n however these methods abstract that further (at the cost of a user structure to store the repeat delay in (which\n the alarm framework does not have space for)."]
pub type repeating_timer_t = repeating_timer;
#[doc = " \\brief Callback for a repeating timer\n \\ingroup repeating_timer\n \\param rt repeating time structure containing information about the repeating time. user_data is of primary important to the user\n \\return true to continue repeating, false to stop."]
pub type repeating_timer_callback_t =
    ::core::option::Option<unsafe extern "C" fn(rt: *mut repeating_timer_t) -> bool>;
#[doc = " \\brief Information about a repeating timer\n \\ingroup repeating_timer\n \\return"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct repeating_timer {
    pub delay_us: i64,
    pub pool: *mut alarm_pool_t,
    pub alarm_id: alarm_id_t,
    pub callback: repeating_timer_callback_t,
    pub user_data: *mut ::core::ffi::c_void,
}
extern "C" {
    #[doc = " \\brief Add a repeating timer that is called repeatedly at the specified interval in microseconds\n \\ingroup repeating_timer\n\n Generally the callback is called as soon as possible after the time specified from an IRQ handler\n on the core the alarm pool was created on. If the callback is in the past or happens before\n the alarm setup could be completed, then this method will optionally call the callback itself\n and then return a return code to indicate that the target time has passed.\n\n \\note It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.\n\n @param pool the alarm pool to use for scheduling the repeating timer (this determines which hardware alarm is used, and which core calls the callback)\n @param delay_us the repeat delay in microseconds; if >0 then this is the delay between one callback ending and the next starting; if <0 then this is the negative of the time between the starts of the callbacks. The value of 0 is treated as 1\n @param callback the repeating timer callback function\n @param user_data user data to pass to store in the repeating_timer structure for use by the callback.\n @param out the pointer to the user owned structure to store the repeating timer info in. BEWARE this storage location must outlive the repeating timer, so be careful of using stack space\n @return false if there were no alarm slots available to create the timer, true otherwise."]
    pub fn alarm_pool_add_repeating_timer_us(
        pool: *mut alarm_pool_t,
        delay_us: i64,
        callback: repeating_timer_callback_t,
        user_data: *mut ::core::ffi::c_void,
        out: *mut repeating_timer_t,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Cancel a repeating timer\n \\ingroup repeating_timer\n \\param timer the repeating timer to cancel\n \\return true if the repeating timer was cancelled, false if it didn't exist\n \\sa alarm_id_t for a note on reuse of IDs"]
    pub fn cancel_repeating_timer(timer: *mut repeating_timer_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct interp_hw_t {
    pub accum: [io_rw_32; 2usize],
    pub base: [io_rw_32; 3usize],
    pub pop: [io_ro_32; 3usize],
    pub peek: [io_ro_32; 3usize],
    pub ctrl: [io_rw_32; 2usize],
    pub add_raw: [io_rw_32; 2usize],
    pub base01: io_wo_32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sio_hw_t {
    pub cpuid: io_ro_32,
    pub gpio_in: io_ro_32,
    pub gpio_hi_in: io_ro_32,
    pub _pad0: u32,
    pub gpio_out: io_rw_32,
    pub gpio_set: io_wo_32,
    pub gpio_clr: io_wo_32,
    pub gpio_togl: io_wo_32,
    pub gpio_oe: io_rw_32,
    pub gpio_oe_set: io_wo_32,
    pub gpio_oe_clr: io_wo_32,
    pub gpio_oe_togl: io_wo_32,
    pub gpio_hi_out: io_rw_32,
    pub gpio_hi_set: io_wo_32,
    pub gpio_hi_clr: io_wo_32,
    pub gpio_hi_togl: io_wo_32,
    pub gpio_hi_oe: io_rw_32,
    pub gpio_hi_oe_set: io_wo_32,
    pub gpio_hi_oe_clr: io_wo_32,
    pub gpio_hi_oe_togl: io_wo_32,
    pub fifo_st: io_rw_32,
    pub fifo_wr: io_wo_32,
    pub fifo_rd: io_ro_32,
    pub spinlock_st: io_ro_32,
    pub div_udividend: io_rw_32,
    pub div_udivisor: io_rw_32,
    pub div_sdividend: io_rw_32,
    pub div_sdivisor: io_rw_32,
    pub div_quotient: io_rw_32,
    pub div_remainder: io_rw_32,
    pub div_csr: io_ro_32,
    pub _pad1: u32,
    pub interp: [interp_hw_t; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct padsbank0_hw_t {
    pub voltage_select: io_rw_32,
    pub io: [io_rw_32; 30usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iobank0_status_ctrl_hw_t {
    pub status: io_ro_32,
    pub ctrl: io_rw_32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_irq_ctrl_hw_t {
    pub inte: [io_rw_32; 4usize],
    pub intf: [io_rw_32; 4usize],
    pub ints: [io_ro_32; 4usize],
}
#[doc = " \\tag::iobank0_hw[]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iobank0_hw_t {
    pub io: [iobank0_status_ctrl_hw_t; 30usize],
    pub intr: [io_rw_32; 4usize],
    pub proc0_irq_ctrl: io_irq_ctrl_hw_t,
    pub proc1_irq_ctrl: io_irq_ctrl_hw_t,
    pub dormant_wake_irq_ctrl: io_irq_ctrl_hw_t,
}
#[doc = " \\brief Interrupt handler function type\n  \\ingroup hardware_irq\n\n All interrupts handlers should be of this type, and follow normal ARM EABI register saving conventions"]
pub type irq_handler_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " \\brief Set specified interrupt's priority\n  \\ingroup hardware_irq\n\n \\param num Interrupt number \\ref interrupt_nums\n \\param hardware_priority Priority to set.\n Numerically-lower values indicate a higher priority. Hardware priorities\n range from 0 (highest priority) to 255 (lowest priority) though only the\n top 2 bits are significant on ARM Cortex-M0+. To make it easier to specify\n higher or lower priorities than the default, all IRQ priorities are\n initialized to PICO_DEFAULT_IRQ_PRIORITY by the SDK runtime at startup.\n PICO_DEFAULT_IRQ_PRIORITY defaults to 0x80"]
    pub fn irq_set_priority(num: uint, hardware_priority: u8);
}
extern "C" {
    #[doc = " \\brief Get specified interrupt's priority\n  \\ingroup hardware_irq\n\n Numerically-lower values indicate a higher priority. Hardware priorities\n range from 0 (highest priority) to 255 (lowest priority) though only the\n top 2 bits are significant on ARM Cortex-M0+. To make it easier to specify\n higher or lower priorities than the default, all IRQ priorities are\n initialized to PICO_DEFAULT_IRQ_PRIORITY by the SDK runtime at startup.\n PICO_DEFAULT_IRQ_PRIORITY defaults to 0x80\n\n \\param num Interrupt number \\ref interrupt_nums\n \\return the IRQ priority"]
    pub fn irq_get_priority(num: uint) -> uint;
}
extern "C" {
    #[doc = " \\brief Enable or disable a specific interrupt on the executing core\n  \\ingroup hardware_irq\n\n \\param num Interrupt number \\ref interrupt_nums\n \\param enabled true to enable the interrupt, false to disable"]
    pub fn irq_set_enabled(num: uint, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Determine if a specific interrupt is enabled on the executing core\n  \\ingroup hardware_irq\n\n \\param num Interrupt number \\ref interrupt_nums\n \\return true if the interrupt is enabled"]
    pub fn irq_is_enabled(num: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Enable/disable multiple interrupts on the executing core\n  \\ingroup hardware_irq\n\n \\param mask 32-bit mask with one bits set for the interrupts to enable/disable \\ref interrupt_nums\n \\param enabled true to enable the interrupts, false to disable them."]
    pub fn irq_set_mask_enabled(mask: u32, enabled: bool);
}
extern "C" {
    #[doc = " \\brief  Set an exclusive interrupt handler for an interrupt on the executing core.\n  \\ingroup hardware_irq\n\n Use this method to set a handler for single IRQ source interrupts, or when\n your code, use case or performance requirements dictate that there should\n no other handlers for the interrupt.\n\n This method will assert if there is already any sort of interrupt handler installed\n for the specified irq number.\n\n \\param num Interrupt number \\ref interrupt_nums\n \\param handler The handler to set. See \\ref irq_handler_t\n \\see irq_add_shared_handler()"]
    pub fn irq_set_exclusive_handler(num: uint, handler: irq_handler_t);
}
extern "C" {
    #[doc = " \\brief  Get the exclusive interrupt handler for an interrupt on the executing core.\n  \\ingroup hardware_irq\n\n This method will return an exclusive IRQ handler set on this core\n by irq_set_exclusive_handler if there is one.\n\n \\param num Interrupt number \\ref interrupt_nums\n \\see irq_set_exclusive_handler()\n \\return handler The handler if an exclusive handler is set for the IRQ,\n                 NULL if no handler is set or shared/shareable handlers are installed"]
    pub fn irq_get_exclusive_handler(num: uint) -> irq_handler_t;
}
extern "C" {
    #[doc = " \\brief Add a shared interrupt handler for an interrupt on the executing core\n  \\ingroup hardware_irq\n\n Use this method to add a handler on an irq number shared between multiple distinct hardware sources (e.g. GPIO, DMA or PIO IRQs).\n Handlers added by this method will all be called in sequence from highest order_priority to lowest. The\n irq_set_exclusive_handler() method should be used instead if you know there will or should only ever be one handler for the interrupt.\n\n This method will assert if there is an exclusive interrupt handler set for this irq number on this core, or if\n the (total across all IRQs on both cores) maximum (configurable via PICO_MAX_SHARED_IRQ_HANDLERS) number of shared handlers\n would be exceeded.\n\n \\param num Interrupt number \\ref interrupt_nums\n \\param handler The handler to set. See \\ref irq_handler_t\n \\param order_priority The order priority controls the order that handlers for the same IRQ number on the core are called.\n The shared irq handlers for an interrupt are all called when an IRQ fires, however the order of the calls is based\n on the order_priority (higher priorities are called first, identical priorities are called in undefined order). A good\n rule of thumb is to use PICO_SHARED_IRQ_HANDLER_DEFAULT_ORDER_PRIORITY if you don't much care, as it is in the middle of\n the priority range by default.\n\n \\note The order_priority uses \\em higher values for higher priorities which is the \\em opposite of the CPU interrupt priorities passed\n to irq_set_priority() which use lower values for higher priorities.\n\n \\see irq_set_exclusive_handler()"]
    pub fn irq_add_shared_handler(num: uint, handler: irq_handler_t, order_priority: u8);
}
extern "C" {
    #[doc = " \\brief Remove a specific interrupt handler for the given irq number on the executing core\n  \\ingroup hardware_irq\n\n This method may be used to remove an irq set via either irq_set_exclusive_handler() or\n irq_add_shared_handler(), and will assert if the handler is not currently installed for the given\n IRQ number\n\n \\note This method may *only* be called from user (non IRQ code) or from within the handler\n itself (i.e. an IRQ handler may remove itself as part of handling the IRQ). Attempts to call\n from another IRQ will cause an assertion.\n\n \\param num Interrupt number \\ref interrupt_nums\n \\param handler The handler to removed.\n \\see irq_set_exclusive_handler()\n \\see irq_add_shared_handler()"]
    pub fn irq_remove_handler(num: uint, handler: irq_handler_t);
}
extern "C" {
    #[doc = " \\brief Determine if the current handler for the given number is shared\n  \\ingroup hardware_irq\n\n \\param num Interrupt number \\ref interrupt_nums\n \\return true if the specified IRQ has a shared handler"]
    pub fn irq_has_shared_handler(num: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Get the current IRQ handler for the specified IRQ from the currently installed hardware vector table (VTOR)\n of the execution core\n  \\ingroup hardware_irq\n\n \\param num Interrupt number \\ref interrupt_nums\n \\return the address stored in the VTABLE for the given irq number"]
    pub fn irq_get_vtable_handler(num: uint) -> irq_handler_t;
}
extern "C" {
    #[doc = " \\brief Force an interrupt to be pending on the executing core\n  \\ingroup hardware_irq\n\n This should generally not be used for IRQs connected to hardware.\n\n \\param num Interrupt number \\ref interrupt_nums"]
    pub fn irq_set_pending(num: uint);
}
extern "C" {
    #[doc = " \\brief Perform IRQ priority initialization for the current core\n\n \\note This is an internal method and user should generally not call it."]
    pub fn irq_init_priorities();
}
extern "C" {
    #[doc = " \\brief Claim ownership of a user IRQ on the calling core\n  \\ingroup hardware_irq\n\n User IRQs are numbered 26-31 and are not connected to any hardware, but can be triggered by \\ref irq_set_pending.\n\n \\note User IRQs are a core local feature; they cannot be used to communicate between cores. Therfore all functions\n dealing with Uer IRQs affect only the calling core\n\n This method explicitly claims ownership of a user IRQ, so other code can know it is being used.\n\n \\param irq_num the user IRQ to claim"]
    pub fn user_irq_claim(irq_num: uint);
}
extern "C" {
    #[doc = " \\brief Mark a user IRQ as no longer used on the calling core\n  \\ingroup hardware_irq\n\n User IRQs are numbered 26-31 and are not connected to any hardware, but can be triggered by \\ref irq_set_pending.\n\n \\note User IRQs are a core local feature; they cannot be used to communicate between cores. Therfore all functions\n dealing with Uer IRQs affect only the calling core\n\n This method explicitly releases ownership of a user IRQ, so other code can know it is free to use.\n\n \\note it is customary to have disabled the irq and removed the handler prior to calling this method.\n\n \\param irq_num the irq irq_num to unclaim"]
    pub fn user_irq_unclaim(irq_num: uint);
}
extern "C" {
    #[doc = " \\brief Claim ownership of a free user IRQ on the calling core\n  \\ingroup hardware_irq\n\n User IRQs are numbered 26-31 and are not connected to any hardware, but can be triggered by \\ref irq_set_pending.\n\n \\note User IRQs are a core local feature; they cannot be used to communicate between cores. Therfore all functions\n dealing with Uer IRQs affect only the calling core\n\n This method explicitly claims ownership of an unused user IRQ if there is one, so other code can know it is being used.\n\n \\param required if true the function will panic if none are available\n \\return the user IRQ number or -1 if required was false, and none were free"]
    pub fn user_irq_claim_unused(required: bool) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn user_irq_is_claimed(irq_num: uint) -> bool;
}
pub const GPIO_FUNC_XIP: gpio_function = 0;
pub const GPIO_FUNC_SPI: gpio_function = 1;
pub const GPIO_FUNC_UART: gpio_function = 2;
pub const GPIO_FUNC_I2C: gpio_function = 3;
pub const GPIO_FUNC_PWM: gpio_function = 4;
pub const GPIO_FUNC_SIO: gpio_function = 5;
pub const GPIO_FUNC_PIO0: gpio_function = 6;
pub const GPIO_FUNC_PIO1: gpio_function = 7;
pub const GPIO_FUNC_GPCK: gpio_function = 8;
pub const GPIO_FUNC_USB: gpio_function = 9;
pub const GPIO_FUNC_NULL: gpio_function = 31;
#[doc = " \\brief  GPIO function definitions for use with function select\n  \\ingroup hardware_gpio\n \\brief GPIO function selectors\n\n Each GPIO can have one function selected at a time. Likewise, each peripheral input (e.g. UART0 RX) should only be\n selected on one GPIO at a time. If the same peripheral input is connected to multiple GPIOs, the peripheral sees the logical\n OR of these GPIO inputs.\n\n Please refer to the datasheet for more information on GPIO function selection."]
pub type gpio_function = ::core::ffi::c_uint;
pub const GPIO_IRQ_LEVEL_LOW: gpio_irq_level = 1;
pub const GPIO_IRQ_LEVEL_HIGH: gpio_irq_level = 2;
pub const GPIO_IRQ_EDGE_FALL: gpio_irq_level = 4;
pub const GPIO_IRQ_EDGE_RISE: gpio_irq_level = 8;
#[doc = " \\brief  GPIO Interrupt level definitions (GPIO events)\n  \\ingroup hardware_gpio\n  \\brief GPIO Interrupt levels\n\n An interrupt can be generated for every GPIO pin in 4 scenarios:\n\n * Level High: the GPIO pin is a logical 1\n * Level Low: the GPIO pin is a logical 0\n * Edge High: the GPIO has transitioned from a logical 0 to a logical 1\n * Edge Low: the GPIO has transitioned from a logical 1 to a logical 0\n\n The level interrupts are not latched. This means that if the pin is a logical 1 and the level high interrupt is active, it will\n become inactive as soon as the pin changes to a logical 0. The edge interrupts are stored in the INTR register and can be\n cleared by writing to the INTR register."]
pub type gpio_irq_level = ::core::ffi::c_uint;
#[doc = " Callback function type for GPIO events\n  \\ingroup hardware_gpio\n\n \\param gpio Which GPIO caused this interrupt\n \\param event_mask Which events caused this interrupt. See \\ref gpio_irq_level for details.\n \\sa gpio_set_irq_enabled_with_callback()\n \\sa gpio_set_irq_callback()"]
pub type gpio_irq_callback_t =
    ::core::option::Option<unsafe extern "C" fn(gpio: uint, event_mask: u32)>;
#[doc = "< peripheral signal selected via \\ref gpio_set_function"]
pub const GPIO_OVERRIDE_NORMAL: gpio_override = 0;
#[doc = "< invert peripheral signal selected via \\ref gpio_set_function"]
pub const GPIO_OVERRIDE_INVERT: gpio_override = 1;
#[doc = "< drive low/disable output"]
pub const GPIO_OVERRIDE_LOW: gpio_override = 2;
#[doc = "< drive high/enable output"]
pub const GPIO_OVERRIDE_HIGH: gpio_override = 3;
pub type gpio_override = ::core::ffi::c_uint;
#[doc = "< Slew rate limiting enabled"]
pub const GPIO_SLEW_RATE_SLOW: gpio_slew_rate = 0;
#[doc = "< Slew rate limiting disabled"]
pub const GPIO_SLEW_RATE_FAST: gpio_slew_rate = 1;
#[doc = " \\brief Slew rate limiting levels for GPIO outputs\n  \\ingroup hardware_gpio\n\n Slew rate limiting increases the minimum rise/fall time when a GPIO output\n is lightly loaded, which can help to reduce electromagnetic emissions.\n \\sa gpio_set_slew_rate"]
pub type gpio_slew_rate = ::core::ffi::c_uint;
#[doc = "< 2 mA nominal drive strength"]
pub const GPIO_DRIVE_STRENGTH_2MA: gpio_drive_strength = 0;
#[doc = "< 4 mA nominal drive strength"]
pub const GPIO_DRIVE_STRENGTH_4MA: gpio_drive_strength = 1;
#[doc = "< 8 mA nominal drive strength"]
pub const GPIO_DRIVE_STRENGTH_8MA: gpio_drive_strength = 2;
#[doc = "< 12 mA nominal drive strength"]
pub const GPIO_DRIVE_STRENGTH_12MA: gpio_drive_strength = 3;
#[doc = " \\brief Drive strength levels for GPIO outputs\n  \\ingroup hardware_gpio\n\n Drive strength levels for GPIO outputs.\n \\sa gpio_set_drive_strength"]
pub type gpio_drive_strength = ::core::ffi::c_uint;
extern "C" {
    #[doc = " \\brief Select GPIO function\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\param fn Which GPIO function select to use from list \\ref gpio_function"]
    pub fn gpio_set_function(gpio: uint, fn_: gpio_function);
}
extern "C" {
    #[doc = " \\brief Determine current GPIO function\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\return Which GPIO function is currently selected from list \\ref gpio_function"]
    pub fn gpio_get_function(gpio: uint) -> gpio_function;
}
extern "C" {
    #[doc = " \\brief Select up and down pulls on specific GPIO\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\param up If true set a pull up on the GPIO\n \\param down If true set a pull down on the GPIO\n\n \\note On the RP2040, setting both pulls enables a \"bus keep\" function,\n i.e. a weak pull to whatever is current high/low state of GPIO."]
    pub fn gpio_set_pulls(gpio: uint, up: bool, down: bool);
}
extern "C" {
    #[doc = " \\brief Set GPIO IRQ override\n  \\ingroup hardware_gpio\n\n Optionally invert a GPIO IRQ signal, or drive it high or low\n\n \\param gpio GPIO number\n \\param value See \\ref gpio_override"]
    pub fn gpio_set_irqover(gpio: uint, value: uint);
}
extern "C" {
    #[doc = " \\brief Set GPIO output override\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\param value See \\ref gpio_override"]
    pub fn gpio_set_outover(gpio: uint, value: uint);
}
extern "C" {
    #[doc = " \\brief Select GPIO input override\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\param value See \\ref gpio_override"]
    pub fn gpio_set_inover(gpio: uint, value: uint);
}
extern "C" {
    #[doc = " \\brief Select GPIO output enable override\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\param value See \\ref gpio_override"]
    pub fn gpio_set_oeover(gpio: uint, value: uint);
}
extern "C" {
    #[doc = " \\brief Enable GPIO input\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\param enabled true to enable input on specified GPIO"]
    pub fn gpio_set_input_enabled(gpio: uint, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Enable/disable GPIO input hysteresis (Schmitt trigger)\n  \\ingroup hardware_gpio\n\n Enable or disable the Schmitt trigger hysteresis on a given GPIO. This is\n enabled on all GPIOs by default. Disabling input hysteresis can lead to\n inconsistent readings when the input signal has very long rise or fall\n times, but slightly reduces the GPIO's input delay.\n\n \\sa gpio_is_input_hysteresis_enabled\n \\param gpio GPIO number\n \\param enabled true to enable input hysteresis on specified GPIO"]
    pub fn gpio_set_input_hysteresis_enabled(gpio: uint, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Determine whether input hysteresis is enabled on a specified GPIO\n  \\ingroup hardware_gpio\n\n \\sa gpio_set_input_hysteresis_enabled\n \\param gpio GPIO number"]
    pub fn gpio_is_input_hysteresis_enabled(gpio: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Set slew rate for a specified GPIO\n  \\ingroup hardware_gpio\n\n \\sa gpio_get_slew_rate\n \\param gpio GPIO number\n \\param slew GPIO output slew rate"]
    pub fn gpio_set_slew_rate(gpio: uint, slew: gpio_slew_rate);
}
extern "C" {
    #[doc = " \\brief Determine current slew rate for a specified GPIO\n  \\ingroup hardware_gpio\n\n \\sa gpio_set_slew_rate\n \\param gpio GPIO number\n \\return Current slew rate of that GPIO"]
    pub fn gpio_get_slew_rate(gpio: uint) -> gpio_slew_rate;
}
extern "C" {
    #[doc = " \\brief Set drive strength for a specified GPIO\n  \\ingroup hardware_gpio\n\n \\sa gpio_get_drive_strength\n \\param gpio GPIO number\n \\param drive GPIO output drive strength"]
    pub fn gpio_set_drive_strength(gpio: uint, drive: gpio_drive_strength);
}
extern "C" {
    #[doc = " \\brief Determine current slew rate for a specified GPIO\n  \\ingroup hardware_gpio\n\n \\sa gpio_set_drive_strength\n \\param gpio GPIO number\n \\return Current drive strength of that GPIO"]
    pub fn gpio_get_drive_strength(gpio: uint) -> gpio_drive_strength;
}
extern "C" {
    #[doc = " \\brief Enable or disable specific interrupt events for specified GPIO\n  \\ingroup hardware_gpio\n\n This function sets which GPIO events cause a GPIO interrupt on the calling core. See\n \\ref gpio_set_irq_callback, \\ref gpio_set_irq_enabled_with_callback and\n \\ref gpio_add_raw_irq_handler to set up a GPIO interrupt handler to handle the events.\n\n \\note The IO IRQs are independent per-processor. This configures the interrupt events for\n the processor that calls the function.\n\n \\param gpio GPIO number\n \\param event_mask Which events will cause an interrupt\n \\param enabled Enable or disable flag\n\n Events is a bitmask of the following \\ref gpio_irq_level values:\n\n bit | constant            | interrupt\n ----|----------------------------------------------------------\n   0 | GPIO_IRQ_LEVEL_LOW  | Continuously while level is low\n   1 | GPIO_IRQ_LEVEL_HIGH | Continuously while level is high\n   2 | GPIO_IRQ_EDGE_FALL  | On each transition from high to low\n   3 | GPIO_IRQ_EDGE_RISE  | On each transition from low to high\n\n which are specified in \\ref gpio_irq_level"]
    pub fn gpio_set_irq_enabled(gpio: uint, event_mask: u32, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Set the generic callback used for GPIO IRQ events for the current core\n  \\ingroup hardware_gpio\n\n This function sets the callback used for all GPIO IRQs on the current core that are not explicitly\n hooked via \\ref gpio_add_raw_irq_handler or other gpio_add_raw_irq_handler_ functions.\n\n This function is called with the GPIO number and event mask for each of the (not explicitly hooked)\n GPIOs that have events enabled and that are pending (see \\ref gpio_get_irq_event_mask).\n\n \\note The IO IRQs are independent per-processor. This function affects\n the processor that calls the function.\n\n \\param callback default user function to call on GPIO irq. Note only one of these can be set per processor."]
    pub fn gpio_set_irq_callback(callback: gpio_irq_callback_t);
}
extern "C" {
    #[doc = " \\brief Convenience function which performs multiple GPIO IRQ related initializations\n  \\ingroup hardware_gpio\n\n This method is a slightly eclectic mix of initialization, that:\n\n \\li Updates whether the specified events for the specified GPIO causes an interrupt on the calling core based\n on the enable flag.\n\n \\li Sets the callback handler for the calling core to callback (or clears the handler if the callback is NULL).\n\n \\li Enables GPIO IRQs on the current core if enabled is true.\n\n This method is commonly used to perform a one time setup, and following that any additional IRQs/events are enabled\n via \\ref gpio_set_irq_enabled. All GPIOs/events added in this way on the same core share the same callback; for multiple\n independent handlers for different GPIOs you should use \\ref gpio_add_raw_irq_handler and related functions.\n\n This method is equivalent to:\n\n \\code{.c}\n gpio_set_irq_enabled(gpio, event_mask, enabled);\n gpio_set_irq_callback(callback);\n if (enabled) irq_set_enabled(IO_IRQ_BANK0, true);\n \\endcode\n\n \\note The IO IRQs are independent per-processor. This method affects only the processor that calls the function.\n\n \\param gpio GPIO number\n \\param event_mask Which events will cause an interrupt. See \\ref gpio_irq_level for details.\n \\param enabled Enable or disable flag\n \\param callback user function to call on GPIO irq. if NULL, the callback is removed"]
    pub fn gpio_set_irq_enabled_with_callback(
        gpio: uint,
        event_mask: u32,
        enabled: bool,
        callback: gpio_irq_callback_t,
    );
}
extern "C" {
    #[doc = " \\brief Enable dormant wake up interrupt for specified GPIO and events\n  \\ingroup hardware_gpio\n\n This configures IRQs to restart the XOSC or ROSC when they are\n disabled in dormant mode\n\n \\param gpio GPIO number\n \\param event_mask Which events will cause an interrupt. See \\ref gpio_irq_level for details.\n \\param enabled Enable/disable flag"]
    pub fn gpio_set_dormant_irq_enabled(gpio: uint, event_mask: u32, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Acknowledge a GPIO interrupt for the specified events on the calling core\n  \\ingroup hardware_gpio\n\n \\note This may be called with a mask of any of valid bits specified in \\ref gpio_irq_level, however\n it has no effect on \\a level sensitive interrupts which remain pending while the GPIO is at the specified\n level. When handling \\a level sensitive interrupts, you should generally disable the interrupt (see\n \\ref gpio_set_irq_enabled) and then set it up again later once the GPIO level has changed (or to catch\n the opposite level).\n\n \\param gpio GPIO number\n\n \\note For callbacks set with \\ref gpio_set_irq_enabled_with_callback, or \\ref gpio_set_irq_callback, this function is called automatically.\n \\param event_mask Bitmask of events to clear. See \\ref gpio_irq_level for details."]
    pub fn gpio_acknowledge_irq(gpio: uint, event_mask: u32);
}
extern "C" {
    #[doc = " \\brief Adds a raw GPIO IRQ handler for the specified GPIOs on the current core\n  \\ingroup hardware_gpio\n\n In addition to the default mechanism of a single GPIO IRQ event callback per core (see \\ref gpio_set_irq_callback),\n it is possible to add explicit GPIO IRQ handlers which are called independent of the default callback. The order\n relative to the default callback can be controlled via the order_priority parameter (the default callback has the priority\n \\ref GPIO_IRQ_CALLBACK_ORDER_PRIORITY which defaults to the lowest priority with the intention of it running last).\n\n This method adds such an explicit GPIO IRQ handler, and disables the \"default\" callback for the specified GPIOs.\n\n \\note Multiple raw handlers should not be added for the same GPIOs, and this method will assert if you attempt to.\n\n A raw handler should check for whichever GPIOs and events it handles, and acknowledge them itself; it might look something like:\n\n \\code{.c}\n void my_irq_handler(void) {\n     if (gpio_get_irq_event_mask(my_gpio_num) & my_gpio_event_mask) {\n        gpio_acknowledge_irq(my_gpio_num, my_gpio_event_mask);\n       // handle the IRQ\n     }\n     if (gpio_get_irq_event_mask(my_gpio_num2) & my_gpio_event_mask2) {\n        gpio_acknowledge_irq(my_gpio_num2, my_gpio_event_mask2);\n       // handle the IRQ\n     }\n }\n \\endcode\n\n @param gpio_mask a bit mask of the GPIO numbers that will no longer be passed to the default callback for this core\n @param handler the handler to add to the list of GPIO IRQ handlers for this core\n @param order_priority the priority order to determine the relative position of the handler in the list of GPIO IRQ handlers for this core."]
    pub fn gpio_add_raw_irq_handler_with_order_priority_masked(
        gpio_mask: uint,
        handler: irq_handler_t,
        order_priority: u8,
    );
}
extern "C" {
    #[doc = " \\brief Adds a raw GPIO IRQ handler for the specified GPIOs on the current core\n  \\ingroup hardware_gpio\n\n In addition to the default mechanism of a single GPIO IRQ event callback per core (see \\ref gpio_set_irq_callback),\n it is possible to add explicit GPIO IRQ handlers which are called independent of the default event callback.\n\n This method adds such a callback, and disables the \"default\" callback for the specified GPIOs.\n\n \\note Multiple raw handlers should not be added for the same GPIOs, and this method will assert if you attempt to.\n\n A raw handler should check for whichever GPIOs and events it handles, and acknowledge them itself; it might look something like:\n\n \\code{.c}\n void my_irq_handler(void) {\n     if (gpio_get_irq_event_mask(my_gpio_num) & my_gpio_event_mask) {\n        gpio_acknowledge_irq(my_gpio_num, my_gpio_event_mask);\n       // handle the IRQ\n     }\n     if (gpio_get_irq_event_mask(my_gpio_num2) & my_gpio_event_mask2) {\n        gpio_acknowledge_irq(my_gpio_num2, my_gpio_event_mask2);\n       // handle the IRQ\n     }\n }\n \\endcode\n\n @param gpio_mask a bit mask of the GPIO numbers that will no longer be passed to the default callback for this core\n @param handler the handler to add to the list of GPIO IRQ handlers for this core"]
    pub fn gpio_add_raw_irq_handler_masked(gpio_mask: uint, handler: irq_handler_t);
}
extern "C" {
    #[doc = " \\brief Removes a raw GPIO IRQ handler for the specified GPIOs on the current core\n  \\ingroup hardware_gpio\n\n In addition to the default mechanism of a single GPIO IRQ event callback per core (see \\ref gpio_set_irq_callback),\n it is possible to add explicit GPIO IRQ handlers which are called independent of the default event callback.\n\n This method removes such a callback, and enables the \"default\" callback for the specified GPIOs.\n\n @param gpio_mask a bit mask of the GPIO numbers that will now be passed to the default callback for this core\n @param handler the handler to remove from the list of GPIO IRQ handlers for this core"]
    pub fn gpio_remove_raw_irq_handler_masked(gpio_mask: uint, handler: irq_handler_t);
}
extern "C" {
    #[doc = " \\brief Initialise a GPIO for (enabled I/O and set func to GPIO_FUNC_SIO)\n  \\ingroup hardware_gpio\n\n Clear the output enable (i.e. set to input).\n Clear any output value.\n\n \\param gpio GPIO number"]
    pub fn gpio_init(gpio: uint);
}
extern "C" {
    #[doc = " \\brief Resets a GPIO back to the NULL function, i.e. disables it.\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number"]
    pub fn gpio_deinit(gpio: uint);
}
extern "C" {
    #[doc = " \\brief Initialise multiple GPIOs (enabled I/O and set func to GPIO_FUNC_SIO)\n  \\ingroup hardware_gpio\n\n Clear the output enable (i.e. set to input).\n Clear any output value.\n\n \\param gpio_mask Mask with 1 bit per GPIO number to initialize"]
    pub fn gpio_init_mask(gpio_mask: uint);
}
extern "C" {
    pub fn gpio_debug_pins_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_hw_t {
    pub dr: io_rw_32,
    pub rsr: io_rw_32,
    pub _pad0: [u32; 4usize],
    pub fr: io_ro_32,
    pub _pad1: u32,
    pub ilpr: io_rw_32,
    pub ibrd: io_rw_32,
    pub fbrd: io_rw_32,
    pub lcr_h: io_rw_32,
    pub cr: io_rw_32,
    pub ifls: io_rw_32,
    pub imsc: io_rw_32,
    pub ris: io_ro_32,
    pub mis: io_ro_32,
    pub icr: io_rw_32,
    pub dmacr: io_rw_32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_inst {
    _unused: [u8; 0],
}
#[doc = " \\file hardware/uart.h\n  \\defgroup hardware_uart hardware_uart\n\n Hardware UART API\n\n RP2040 has 2 identical instances of a UART peripheral, based on the ARM PL011. Each UART can be connected to a number\n of GPIO pins as defined in the GPIO muxing.\n\n Only the TX, RX, RTS, and CTS signals are\n connected, meaning that the modem mode and IrDA mode of the PL011 are not supported.\n\n \\subsection uart_example Example\n \\addtogroup hardware_uart\n\n  \\code\n  int main() {\n\n     // Initialise UART 0\n     uart_init(uart0, 115200);\n\n     // Set the GPIO pin mux to the UART - 0 is TX, 1 is RX\n     gpio_set_function(0, GPIO_FUNC_UART);\n     gpio_set_function(1, GPIO_FUNC_UART);\n\n     uart_puts(uart0, \"Hello world!\");\n }\n \\endcode"]
pub type uart_inst_t = uart_inst;
pub const UART_PARITY_NONE: uart_parity_t = 0;
pub const UART_PARITY_EVEN: uart_parity_t = 1;
pub const UART_PARITY_ODD: uart_parity_t = 2;
#[doc = " \\brief UART Parity enumeration\n  \\ingroup hardware_uart"]
pub type uart_parity_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " \\brief Initialise a UART\n  \\ingroup hardware_uart\n\n Put the UART into a known state, and enable it. Must be called before other\n functions.\n\n This function always enables the FIFOs, and configures the UART for the\n following default line format:\n\n - 8 data bits\n - No parity bit\n - One stop bit\n\n \\note There is no guarantee that the baudrate requested will be possible, the nearest will be chosen,\n and this function will return the configured baud rate.\n\n \\param uart UART instance. \\ref uart0 or \\ref uart1\n \\param baudrate Baudrate of UART in Hz\n \\return Actual set baudrate"]
    pub fn uart_init(uart: *mut uart_inst_t, baudrate: uint) -> uint;
}
extern "C" {
    #[doc = " \\brief DeInitialise a UART\n  \\ingroup hardware_uart\n\n Disable the UART if it is no longer used. Must be reinitialised before\n being used again.\n\n \\param uart UART instance. \\ref uart0 or \\ref uart1"]
    pub fn uart_deinit(uart: *mut uart_inst_t);
}
extern "C" {
    #[doc = " \\brief Set UART baud rate\n  \\ingroup hardware_uart\n\n Set baud rate as close as possible to requested, and return actual rate selected.\n\n The UART is paused for around two character periods whilst the settings are\n changed. Data received during this time may be dropped by the UART.\n\n Any characters still in the transmit buffer will be sent using the new\n updated baud rate. uart_tx_wait_blocking() can be called before this\n function to ensure all characters at the old baud rate have been sent\n before the rate is changed.\n\n This function should not be called from an interrupt context, and the UART\n interrupt should be disabled before calling this function.\n\n \\param uart UART instance. \\ref uart0 or \\ref uart1\n \\param baudrate Baudrate in Hz\n \\return Actual set baudrate"]
    pub fn uart_set_baudrate(uart: *mut uart_inst_t, baudrate: uint) -> uint;
}
extern "C" {
    #[doc = " \\brief Set UART data format\n  \\ingroup hardware_uart\n\n Configure the data format (bits etc) for the UART.\n\n The UART is paused for around two character periods whilst the settings are\n changed. Data received during this time may be dropped by the UART.\n\n Any characters still in the transmit buffer will be sent using the new\n updated data format. uart_tx_wait_blocking() can be called before this\n function to ensure all characters needing the old format have been sent\n before the format is changed.\n\n This function should not be called from an interrupt context, and the UART\n interrupt should be disabled before calling this function.\n\n \\param uart UART instance. \\ref uart0 or \\ref uart1\n \\param data_bits Number of bits of data. 5..8\n \\param stop_bits Number of stop bits 1..2\n \\param parity Parity option."]
    pub fn uart_set_format(
        uart: *mut uart_inst_t,
        data_bits: uint,
        stop_bits: uint,
        parity: uart_parity_t,
    );
}
extern "C" {
    #[doc = " \\brief Enable/Disable the FIFOs on specified UART\n  \\ingroup hardware_uart\n\n The UART is paused for around two character periods whilst the settings are\n changed. Data received during this time may be dropped by the UART.\n\n Any characters still in the transmit FIFO will be lost if the FIFO is\n disabled. uart_tx_wait_blocking() can be called before this\n function to avoid this.\n\n This function should not be called from an interrupt context, and the UART\n interrupt should be disabled when calling this function.\n\n \\param uart UART instance. \\ref uart0 or \\ref uart1\n \\param enabled true to enable FIFO (default), false to disable"]
    pub fn uart_set_fifo_enabled(uart: *mut uart_inst_t, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Assert a break condition on the UART transmission.\n  \\ingroup hardware_uart\n\n \\param uart UART instance. \\ref uart0 or \\ref uart1\n \\param en Assert break condition (TX held low) if true. Clear break condition if false."]
    pub fn uart_set_break(uart: *mut uart_inst_t, en: bool);
}
extern "C" {
    #[doc = " \\brief Set CR/LF conversion on UART\n  \\ingroup hardware_uart\n\n \\param uart UART instance. \\ref uart0 or \\ref uart1\n \\param translate If true, convert line feeds to carriage return on transmissions"]
    pub fn uart_set_translate_crlf(uart: *mut uart_inst_t, translate: bool);
}
extern "C" {
    #[doc = " \\brief Wait for up to a certain number of microseconds for the RX FIFO to be non empty\n  \\ingroup hardware_uart\n\n \\param uart UART instance. \\ref uart0 or \\ref uart1\n \\param us the number of microseconds to wait at most (may be 0 for an instantaneous check)\n \\return true if the RX FIFO became non empty before the timeout, false otherwise"]
    pub fn uart_is_readable_within_us(uart: *mut uart_inst_t, us: u32) -> bool;
}
extern "C" {
    #[doc = " \\brief Set up the default UART and assign it to the default GPIOs\n  \\ingroup pico_stdlib\n\n By default this will use UART 0, with TX to pin GPIO 0,\n RX to pin GPIO 1, and the baudrate to 115200\n\n Calling this method also initializes stdin/stdout over UART if the\n @ref pico_stdio_uart library is linked.\n\n Defaults can be changed using configuration defines,\n  PICO_DEFAULT_UART_INSTANCE,\n  PICO_DEFAULT_UART_BAUD_RATE\n  PICO_DEFAULT_UART_TX_PIN\n  PICO_DEFAULT_UART_RX_PIN"]
    pub fn setup_default_uart();
}
extern "C" {
    #[doc = " \\brief Initialise the system clock to 48MHz\n  \\ingroup pico_stdlib\n\n  Set the system clock to 48MHz, and set the peripheral clock to match."]
    pub fn set_sys_clock_48mhz();
}
extern "C" {
    #[doc = " \\brief Initialise the system clock\n  \\ingroup pico_stdlib\n\n \\param vco_freq The voltage controller oscillator frequency to be used by the SYS PLL\n \\param post_div1 The first post divider for the SYS PLL\n \\param post_div2 The second post divider for the SYS PLL.\n\n See the PLL documentation in the datasheet for details of driving the PLLs."]
    pub fn set_sys_clock_pll(vco_freq: u32, post_div1: uint, post_div2: uint);
}
extern "C" {
    #[doc = " \\brief Check if a given system clock frequency is valid/attainable\n  \\ingroup pico_stdlib\n\n \\param freq_khz Requested frequency\n \\param vco_freq_out On success, the voltage controlled oscillator frequency to be used by the SYS PLL\n \\param post_div1_out On success, The first post divider for the SYS PLL\n \\param post_div2_out On success, The second post divider for the SYS PLL.\n @return true if the frequency is possible and the output parameters have been written."]
    pub fn check_sys_clock_khz(
        freq_khz: u32,
        vco_freq_out: *mut uint,
        post_div1_out: *mut uint,
        post_div2_out: *mut uint,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_hw_t {
    pub cs: io_rw_32,
    pub result: io_ro_32,
    pub fcs: io_rw_32,
    pub fifo: io_ro_32,
    pub div: io_rw_32,
    pub intr: io_ro_32,
    pub inte: io_rw_32,
    pub intf: io_rw_32,
    pub ints: io_ro_32,
}
extern "C" {
    #[doc = " \\brief  Initialise the ADC HW\n  \\ingroup hardware_adc\n"]
    pub fn adc_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_hw_t {
    pub cr0: io_rw_32,
    pub cr1: io_rw_32,
    pub dr: io_rw_32,
    pub sr: io_ro_32,
    pub cpsr: io_rw_32,
    pub imsc: io_rw_32,
    pub ris: io_ro_32,
    pub mis: io_ro_32,
    pub icr: io_rw_32,
    pub dmacr: io_rw_32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_inst {
    _unused: [u8; 0],
}
#[doc = " Opaque type representing an SPI instance."]
pub type spi_inst_t = spi_inst;
pub const SPI_CPHA_0: spi_cpha_t = 0;
pub const SPI_CPHA_1: spi_cpha_t = 1;
#[doc = " \\brief Enumeration of SPI CPHA (clock phase) values.\n  \\ingroup hardware_spi"]
pub type spi_cpha_t = ::core::ffi::c_uint;
pub const SPI_CPOL_0: spi_cpol_t = 0;
pub const SPI_CPOL_1: spi_cpol_t = 1;
#[doc = " \\brief Enumeration of SPI CPOL (clock polarity) values.\n  \\ingroup hardware_spi"]
pub type spi_cpol_t = ::core::ffi::c_uint;
pub const SPI_LSB_FIRST: spi_order_t = 0;
pub const SPI_MSB_FIRST: spi_order_t = 1;
#[doc = " \\brief Enumeration of SPI bit-order values.\n  \\ingroup hardware_spi"]
pub type spi_order_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " \\brief Initialise SPI instances\n  \\ingroup hardware_spi\n Puts the SPI into a known state, and enable it. Must be called before other\n functions.\n\n \\note There is no guarantee that the baudrate requested can be achieved exactly; the nearest will be chosen\n and returned\n\n \\param spi SPI instance specifier, either \\ref spi0 or \\ref spi1\n \\param baudrate Baudrate requested in Hz\n \\return the actual baud rate set"]
    pub fn spi_init(spi: *mut spi_inst_t, baudrate: uint) -> uint;
}
extern "C" {
    #[doc = " \\brief Deinitialise SPI instances\n  \\ingroup hardware_spi\n Puts the SPI into a disabled state. Init will need to be called to reenable the device\n functions.\n\n \\param spi SPI instance specifier, either \\ref spi0 or \\ref spi1"]
    pub fn spi_deinit(spi: *mut spi_inst_t);
}
extern "C" {
    #[doc = " \\brief Set SPI baudrate\n  \\ingroup hardware_spi\n\n Set SPI frequency as close as possible to baudrate, and return the actual\n achieved rate.\n\n \\param spi SPI instance specifier, either \\ref spi0 or \\ref spi1\n \\param baudrate Baudrate required in Hz, should be capable of a bitrate of at least 2Mbps, or higher, depending on system clock settings.\n \\return The actual baudrate set"]
    pub fn spi_set_baudrate(spi: *mut spi_inst_t, baudrate: uint) -> uint;
}
extern "C" {
    #[doc = " \\brief Get SPI baudrate\n  \\ingroup hardware_spi\n\n Get SPI baudrate which was set by \\see spi_set_baudrate\n\n \\param spi SPI instance specifier, either \\ref spi0 or \\ref spi1\n \\return The actual baudrate set"]
    pub fn spi_get_baudrate(spi: *const spi_inst_t) -> uint;
}
extern "C" {
    #[doc = " \\brief Write/Read to/from an SPI device\n  \\ingroup hardware_spi\n\n Write \\p len bytes from \\p src to SPI. Simultaneously read \\p len bytes from SPI to \\p dst.\n Blocks until all data is transferred. No timeout, as SPI hardware always transfers at a known data rate.\n\n \\param spi SPI instance specifier, either \\ref spi0 or \\ref spi1\n \\param src Buffer of data to write\n \\param dst Buffer for read data\n \\param len Length of BOTH buffers\n \\return Number of bytes written/read"]
    pub fn spi_write_read_blocking(
        spi: *mut spi_inst_t,
        src: *const u8,
        dst: *mut u8,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief Write to an SPI device, blocking\n  \\ingroup hardware_spi\n\n Write \\p len bytes from \\p src to SPI, and discard any data received back\n Blocks until all data is transferred. No timeout, as SPI hardware always transfers at a known data rate.\n\n \\param spi SPI instance specifier, either \\ref spi0 or \\ref spi1\n \\param src Buffer of data to write\n \\param len Length of \\p src\n \\return Number of bytes written/read"]
    pub fn spi_write_blocking(
        spi: *mut spi_inst_t,
        src: *const u8,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief Read from an SPI device\n  \\ingroup hardware_spi\n\n Read \\p len bytes from SPI to \\p dst.\n Blocks until all data is transferred. No timeout, as SPI hardware always transfers at a known data rate.\n \\p repeated_tx_data is output repeatedly on TX as data is read in from RX.\n Generally this can be 0, but some devices require a specific value here,\n e.g. SD cards expect 0xff\n\n \\param spi SPI instance specifier, either \\ref spi0 or \\ref spi1\n \\param repeated_tx_data Buffer of data to write\n \\param dst Buffer for read data\n \\param len Length of buffer \\p dst\n \\return Number of bytes written/read"]
    pub fn spi_read_blocking(
        spi: *mut spi_inst_t,
        repeated_tx_data: u8,
        dst: *mut u8,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief Write/Read half words to/from an SPI device\n  \\ingroup hardware_spi\n\n Write \\p len halfwords from \\p src to SPI. Simultaneously read \\p len halfwords from SPI to \\p dst.\n Blocks until all data is transferred. No timeout, as SPI hardware always transfers at a known data rate.\n\n \\note SPI should be initialised with 16 data_bits using \\ref spi_set_format first, otherwise this function will only read/write 8 data_bits.\n\n \\param spi SPI instance specifier, either \\ref spi0 or \\ref spi1\n \\param src Buffer of data to write\n \\param dst Buffer for read data\n \\param len Length of BOTH buffers in halfwords\n \\return Number of halfwords written/read"]
    pub fn spi_write16_read16_blocking(
        spi: *mut spi_inst_t,
        src: *const u16,
        dst: *mut u16,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief Write to an SPI device\n  \\ingroup hardware_spi\n\n Write \\p len halfwords from \\p src to SPI. Discard any data received back.\n Blocks until all data is transferred. No timeout, as SPI hardware always transfers at a known data rate.\n\n \\note SPI should be initialised with 16 data_bits using \\ref spi_set_format first, otherwise this function will only write 8 data_bits.\n\n \\param spi SPI instance specifier, either \\ref spi0 or \\ref spi1\n \\param src Buffer of data to write\n \\param len Length of buffers\n \\return Number of halfwords written/read"]
    pub fn spi_write16_blocking(
        spi: *mut spi_inst_t,
        src: *const u16,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief Read from an SPI device\n  \\ingroup hardware_spi\n\n Read \\p len halfwords from SPI to \\p dst.\n Blocks until all data is transferred. No timeout, as SPI hardware always transfers at a known data rate.\n \\p repeated_tx_data is output repeatedly on TX as data is read in from RX.\n Generally this can be 0, but some devices require a specific value here,\n e.g. SD cards expect 0xff\n\n \\note SPI should be initialised with 16 data_bits using \\ref spi_set_format first, otherwise this function will only read 8 data_bits.\n\n \\param spi SPI instance specifier, either \\ref spi0 or \\ref spi1\n \\param repeated_tx_data Buffer of data to write\n \\param dst Buffer for read data\n \\param len Length of buffer \\p dst in halfwords\n \\return Number of halfwords written/read"]
    pub fn spi_read16_blocking(
        spi: *mut spi_inst_t,
        repeated_tx_data: u16,
        dst: *mut u16,
        len: usize,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_hw_t {
    pub con: io_rw_32,
    pub tar: io_rw_32,
    pub sar: io_rw_32,
    pub _pad0: u32,
    pub data_cmd: io_rw_32,
    pub ss_scl_hcnt: io_rw_32,
    pub ss_scl_lcnt: io_rw_32,
    pub fs_scl_hcnt: io_rw_32,
    pub fs_scl_lcnt: io_rw_32,
    pub _pad1: [u32; 2usize],
    pub intr_stat: io_ro_32,
    pub intr_mask: io_rw_32,
    pub raw_intr_stat: io_ro_32,
    pub rx_tl: io_rw_32,
    pub tx_tl: io_rw_32,
    pub clr_intr: io_ro_32,
    pub clr_rx_under: io_ro_32,
    pub clr_rx_over: io_ro_32,
    pub clr_tx_over: io_ro_32,
    pub clr_rd_req: io_ro_32,
    pub clr_tx_abrt: io_ro_32,
    pub clr_rx_done: io_ro_32,
    pub clr_activity: io_ro_32,
    pub clr_stop_det: io_ro_32,
    pub clr_start_det: io_ro_32,
    pub clr_gen_call: io_ro_32,
    pub enable: io_rw_32,
    pub status: io_ro_32,
    pub txflr: io_ro_32,
    pub rxflr: io_ro_32,
    pub sda_hold: io_rw_32,
    pub tx_abrt_source: io_ro_32,
    pub slv_data_nack_only: io_rw_32,
    pub dma_cr: io_rw_32,
    pub dma_tdlr: io_rw_32,
    pub dma_rdlr: io_rw_32,
    pub sda_setup: io_rw_32,
    pub ack_general_call: io_rw_32,
    pub enable_status: io_ro_32,
    pub fs_spklen: io_rw_32,
    pub _pad2: u32,
    pub clr_restart_det: io_ro_32,
    pub _pad3: [u32; 18usize],
    pub comp_param_1: io_ro_32,
    pub comp_version: io_ro_32,
    pub comp_type: io_ro_32,
}
#[doc = " \\file hardware/i2c.h\n  \\defgroup hardware_i2c hardware_i2c\n\n I2C Controller API\n\n The I2C bus is a two-wire serial interface, consisting of a serial data line SDA and a serial clock SCL. These wires carry\n information between the devices connected to the bus. Each device is recognized by a unique 7-bit address and can operate as\n either a transmitter or receiver, depending on the function of the device. Devices can also be considered as masters or\n slaves when performing data transfers. A master is a device that initiates a data transfer on the bus and generates the\n clock signals to permit that transfer. The first byte in the data transfer always contains the 7-bit address and\n a read/write bit in the LSB position. This API takes care of toggling the read/write bit. After this, any device addressed\n is considered a slave.\n\n This API allows the controller to be set up as a master or a slave using the \\ref i2c_set_slave_mode function.\n\n The external pins of each controller are connected to GPIO pins as defined in the GPIO muxing table in the datasheet. The muxing options\n give some IO flexibility, but each controller external pin should be connected to only one GPIO.\n\n Note that the controller does NOT support High speed mode or Ultra-fast speed mode, the fastest operation being fast mode plus\n at up to 1000Kb/s.\n\n See the datasheet for more information on the I2C controller and its usage.\n\n \\subsection i2c_example Example\n \\addtogroup hardware_i2c\n \\include bus_scan.c"]
pub type i2c_inst_t = i2c_inst;
extern "C" {
    #[doc = " The I2C identifiers for use in I2C functions.\n\n e.g. i2c_init(i2c0, 48000)\n\n  \\ingroup hardware_i2c\n @{"]
    pub static mut i2c0_inst: i2c_inst_t;
}
extern "C" {
    pub static mut i2c1_inst: i2c_inst_t;
}
extern "C" {
    #[doc = " \\brief   Initialise the I2C HW block\n  \\ingroup hardware_i2c\n\n Put the I2C hardware into a known state, and enable it. Must be called\n before other functions. By default, the I2C is configured to operate as a\n master.\n\n The I2C bus frequency is set as close as possible to requested, and\n the actual rate set is returned\n\n \\param i2c Either \\ref i2c0 or \\ref i2c1\n \\param baudrate Baudrate in Hz (e.g. 100kHz is 100000)\n \\return Actual set baudrate"]
    pub fn i2c_init(i2c: *mut i2c_inst_t, baudrate: uint) -> uint;
}
extern "C" {
    #[doc = " \\brief   Disable the I2C HW block\n  \\ingroup hardware_i2c\n\n \\param i2c Either \\ref i2c0 or \\ref i2c1\n\n Disable the I2C again if it is no longer used. Must be reinitialised before\n being used again."]
    pub fn i2c_deinit(i2c: *mut i2c_inst_t);
}
extern "C" {
    #[doc = " \\brief  Set I2C baudrate\n  \\ingroup hardware_i2c\n\n Set I2C bus frequency as close as possible to requested, and return actual\n rate set.\n Baudrate may not be as exactly requested due to clocking limitations.\n\n \\param i2c Either \\ref i2c0 or \\ref i2c1\n \\param baudrate Baudrate in Hz (e.g. 100kHz is 100000)\n \\return Actual set baudrate"]
    pub fn i2c_set_baudrate(i2c: *mut i2c_inst_t, baudrate: uint) -> uint;
}
extern "C" {
    #[doc = " \\brief  Set I2C port to slave mode\n  \\ingroup hardware_i2c\n\n \\param i2c Either \\ref i2c0 or \\ref i2c1\n \\param slave true to use slave mode, false to use master mode\n \\param addr If \\p slave is true, set the slave address to this value"]
    pub fn i2c_set_slave_mode(i2c: *mut i2c_inst_t, slave: bool, addr: u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_inst {
    pub hw: *mut i2c_hw_t,
    pub restart_on_next: bool,
}
extern "C" {
    #[doc = " \\brief Attempt to write specified number of bytes to address, blocking until the specified absolute time is reached.\n  \\ingroup hardware_i2c\n\n \\param i2c Either \\ref i2c0 or \\ref i2c1\n \\param addr 7-bit address of device to write to\n \\param src Pointer to data to send\n \\param len Length of data in bytes to send\n \\param nostop  If true, master retains control of the bus at the end of the transfer (no Stop is issued),\n           and the next transfer will begin with a Restart rather than a Start.\n \\param until The absolute time that the block will wait until the entire transaction is complete. Note, an individual timeout of\n           this value divided by the length of data is applied for each byte transfer, so if the first or subsequent\n           bytes fails to transfer within that sub timeout, the function will return with an error.\n\n \\return Number of bytes written, or PICO_ERROR_GENERIC if address not acknowledged, no device present, or PICO_ERROR_TIMEOUT if a timeout occurred."]
    pub fn i2c_write_blocking_until(
        i2c: *mut i2c_inst_t,
        addr: u8,
        src: *const u8,
        len: usize,
        nostop: bool,
        until: absolute_time_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief  Attempt to read specified number of bytes from address, blocking until the specified absolute time is reached.\n  \\ingroup hardware_i2c\n\n \\param i2c Either \\ref i2c0 or \\ref i2c1\n \\param addr 7-bit address of device to read from\n \\param dst Pointer to buffer to receive data\n \\param len Length of data in bytes to receive\n \\param nostop  If true, master retains control of the bus at the end of the transfer (no Stop is issued),\n           and the next transfer will begin with a Restart rather than a Start.\n \\param until The absolute time that the block will wait until the entire transaction is complete.\n \\return Number of bytes read, or PICO_ERROR_GENERIC if address not acknowledged, no device present, or PICO_ERROR_TIMEOUT if a timeout occurred."]
    pub fn i2c_read_blocking_until(
        i2c: *mut i2c_inst_t,
        addr: u8,
        dst: *mut u8,
        len: usize,
        nostop: bool,
        until: absolute_time_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn i2c_write_timeout_per_char_us(
        i2c: *mut i2c_inst_t,
        addr: u8,
        src: *const u8,
        len: usize,
        nostop: bool,
        timeout_per_char_us: uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn i2c_read_timeout_per_char_us(
        i2c: *mut i2c_inst_t,
        addr: u8,
        dst: *mut u8,
        len: usize,
        nostop: bool,
        timeout_per_char_us: uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief Attempt to write specified number of bytes to address, blocking\n  \\ingroup hardware_i2c\n\n \\param i2c Either \\ref i2c0 or \\ref i2c1\n \\param addr 7-bit address of device to write to\n \\param src Pointer to data to send\n \\param len Length of data in bytes to send\n \\param nostop  If true, master retains control of the bus at the end of the transfer (no Stop is issued),\n           and the next transfer will begin with a Restart rather than a Start.\n \\return Number of bytes written, or PICO_ERROR_GENERIC if address not acknowledged, no device present."]
    pub fn i2c_write_blocking(
        i2c: *mut i2c_inst_t,
        addr: u8,
        src: *const u8,
        len: usize,
        nostop: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief  Attempt to read specified number of bytes from address, blocking\n  \\ingroup hardware_i2c\n\n \\param i2c Either \\ref i2c0 or \\ref i2c1\n \\param addr 7-bit address of device to read from\n \\param dst Pointer to buffer to receive data\n \\param len Length of data in bytes to receive\n \\param nostop  If true, master retains control of the bus at the end of the transfer (no Stop is issued),\n           and the next transfer will begin with a Restart rather than a Start.\n \\return Number of bytes read, or PICO_ERROR_GENERIC if address not acknowledged or no device present."]
    pub fn i2c_read_blocking(
        i2c: *mut i2c_inst_t,
        addr: u8,
        dst: *mut u8,
        len: usize,
        nostop: bool,
    ) -> ::core::ffi::c_int;
}
#[doc = " \\brief A spin lock identifier\n \\ingroup hardware_sync"]
pub type spin_lock_t = u32;
extern "C" {
    #[doc = " \\brief Initialise a spin lock\n  \\ingroup hardware_sync\n\n The spin lock is initially unlocked\n\n \\param lock_num The spin lock number\n \\return The spin lock instance"]
    pub fn spin_lock_init(lock_num: uint) -> *mut spin_lock_t;
}
extern "C" {
    #[doc = " \\brief Release all spin locks\n  \\ingroup hardware_sync"]
    pub fn spin_locks_reset();
}
extern "C" {
    #[doc = " \\brief Return a spin lock number from the _striped_ range\n  \\ingroup hardware_sync\n\n Returns a spin lock number in the range PICO_SPINLOCK_ID_STRIPED_FIRST to PICO_SPINLOCK_ID_STRIPED_LAST\n in a round robin fashion. This does not grant the caller exclusive access to the spin lock, so the caller\n must:\n\n -# Abide (with other callers) by the contract of only holding this spin lock briefly (and with IRQs disabled - the default via \\ref spin_lock_blocking()),\n and not whilst holding other spin locks.\n -# Be OK with any contention caused by the - brief due to the above requirement - contention with other possible users of the spin lock.\n\n \\return lock_num a spin lock number the caller may use (non exclusively)\n \\see PICO_SPINLOCK_ID_STRIPED_FIRST\n \\see PICO_SPINLOCK_ID_STRIPED_LAST"]
    pub fn next_striped_spin_lock_num() -> uint;
}
extern "C" {
    #[doc = " \\brief Mark a spin lock as used\n  \\ingroup hardware_sync\n\n Method for cooperative claiming of hardware. Will cause a panic if the spin lock\n is already claimed. Use of this method by libraries detects accidental\n configurations that would fail in unpredictable ways.\n\n \\param lock_num the spin lock number"]
    pub fn spin_lock_claim(lock_num: uint);
}
extern "C" {
    #[doc = " \\brief Mark multiple spin locks as used\n  \\ingroup hardware_sync\n\n Method for cooperative claiming of hardware. Will cause a panic if any of the spin locks\n are already claimed. Use of this method by libraries detects accidental\n configurations that would fail in unpredictable ways.\n\n \\param lock_num_mask Bitfield of all required spin locks to claim (bit 0 == spin lock 0, bit 1 == spin lock 1 etc)"]
    pub fn spin_lock_claim_mask(lock_num_mask: u32);
}
extern "C" {
    #[doc = " \\brief Mark a spin lock as no longer used\n  \\ingroup hardware_sync\n\n Method for cooperative claiming of hardware.\n\n \\param lock_num the spin lock number to release"]
    pub fn spin_lock_unclaim(lock_num: uint);
}
extern "C" {
    #[doc = " \\brief Claim a free spin lock\n  \\ingroup hardware_sync\n\n \\param required if true the function will panic if none are available\n \\return the spin lock number or -1 if required was false, and none were free"]
    pub fn spin_lock_claim_unused(required: bool) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief Determine if a spin lock is claimed\n  \\ingroup hardware_sync\n\n \\param lock_num the spin lock number\n \\return true if claimed, false otherwise\n \\see spin_lock_claim\n \\see spin_lock_claim_mask"]
    pub fn spin_lock_is_claimed(lock_num: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Atomically claim a resource, panicking if it is already in use\n  \\ingroup hardware_claim\n\n The resource ownership is indicated by the bit_index bit in an array of bits.\n\n \\param bits pointer to an array of bits (8 bits per byte)\n \\param bit_index resource to claim (bit index into array of bits)\n \\param message string to display if the bit cannot be claimed; note this may have a single printf format \"%d\" for the bit"]
    pub fn hw_claim_or_assert(bits: *mut u8, bit_index: uint, message: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " \\brief Atomically claim one resource out of a range of resources, optionally asserting if none are free\n  \\ingroup hardware_claim\n\n \\param bits pointer to an array of bits (8 bits per byte)\n \\param required true if this method should panic if the resource is not free\n \\param bit_lsb the lower bound (inclusive) of the resource range to claim from\n \\param bit_msb the upper bound (inclusive) of the resource range to claim from\n \\param message string to display if the bit cannot be claimed\n \\return the bit index representing the claimed or -1 if none are available in the range, and required = false"]
    pub fn hw_claim_unused_from_range(
        bits: *mut u8,
        required: bool,
        bit_lsb: uint,
        bit_msb: uint,
        message: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief Determine if a resource is claimed at the time of the call\n  \\ingroup hardware_claim\n\n The resource ownership is indicated by the bit_index bit in an array of bits.\n\n \\param bits pointer to an array of bits (8 bits per byte)\n \\param bit_index resource to check (bit index into array of bits)\n \\return true if the resource is claimed"]
    pub fn hw_is_claimed(bits: *const u8, bit_index: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Atomically unclaim a resource\n  \\ingroup hardware_claim\n\n The resource ownership is indicated by the bit_index bit in an array of bits.\n\n \\param bits pointer to an array of bits (8 bits per byte)\n \\param bit_index resource to unclaim (bit index into array of bits)"]
    pub fn hw_claim_clear(bits: *mut u8, bit_index: uint);
}
extern "C" {
    #[doc = " \\brief Acquire the runtime mutual exclusion lock provided by the `hardware_claim` library\n  \\ingroup hardware_claim\n\n This method is called automatically by the other `hw_claim_` methods, however it is provided as a convenience\n to code that might want to protect other hardware initialization code from concurrent use.\n\n \\note hw_claim_lock() uses a spin lock internally, so disables interrupts on the calling core, and will deadlock\n if the calling core already owns the lock.\n\n \\return a token to pass to hw_claim_unlock()"]
    pub fn hw_claim_lock() -> u32;
}
extern "C" {
    #[doc = " \\brief Release the runtime mutual exclusion lock provided by the `hardware_claim` library\n  \\ingroup hardware_claim\n\n \\note This method MUST be called from the same core that call hw_claim_lock()\n\n \\param token the token returned by the corresponding call to hw_claim_lock()"]
    pub fn hw_claim_unlock(token: u32);
}
pub type divmod_result_t = u64;
extern "C" {
    #[doc = " \\brief Do a signed HW divide and wait for result\n  \\ingroup hardware_divider\n\n Divide \\p a by \\p b, wait for calculation to complete, return result as a pair of 32-bit quotient/remainder values.\n\n \\param a The dividend\n \\param b The divisor\n \\return Results of divide as a pair of 32-bit quotient/remainder values."]
    pub fn hw_divider_divmod_s32(a: i32, b: i32) -> divmod_result_t;
}
extern "C" {
    #[doc = " \\brief Do an unsigned HW divide and wait for result\n  \\ingroup hardware_divider\n\n Divide \\p a by \\p b, wait for calculation to complete, return result as a pair of 32-bit quotient/remainder values.\n\n \\param a The dividend\n \\param b The divisor\n \\return Results of divide as a pair of 32-bit quotient/remainder values."]
    pub fn hw_divider_divmod_u32(a: u32, b: u32) -> divmod_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_divider_state_t {
    pub values: [u32; 4usize],
}
extern "C" {
    #[doc = " \\brief Save the calling cores hardware divider state\n  \\ingroup hardware_divider\n\n Copy the current core's hardware divider state into the provided structure. This method\n waits for the divider results to be stable, then copies them to memory.\n They can be restored via hw_divider_restore_state()\n\n \\param dest the location to store the divider state"]
    pub fn hw_divider_save_state(dest: *mut hw_divider_state_t);
}
extern "C" {
    #[doc = " \\brief Load a saved hardware divider state into the current core's hardware divider\n  \\ingroup hardware_divider\n\n Copy the passed hardware divider state into the hardware divider.\n\n \\param src the location to load the divider state from"]
    pub fn hw_divider_restore_state(src: *mut hw_divider_state_t);
}
#[doc = "< GPIO Muxing 0"]
pub const clk_gpout0: clock_index = 0;
#[doc = "< GPIO Muxing 1"]
pub const clk_gpout1: clock_index = 1;
#[doc = "< GPIO Muxing 2"]
pub const clk_gpout2: clock_index = 2;
#[doc = "< GPIO Muxing 3"]
pub const clk_gpout3: clock_index = 3;
#[doc = "< Watchdog and timers reference clock"]
pub const clk_ref: clock_index = 4;
#[doc = "< Processors, bus fabric, memory, memory mapped registers"]
pub const clk_sys: clock_index = 5;
#[doc = "< Peripheral clock for UART and SPI"]
pub const clk_peri: clock_index = 6;
#[doc = "< USB clock"]
pub const clk_usb: clock_index = 7;
#[doc = "< ADC clock"]
pub const clk_adc: clock_index = 8;
#[doc = "< Real time clock"]
pub const clk_rtc: clock_index = 9;
pub const CLK_COUNT: clock_index = 10;
#[doc = " \\brief Enumeration identifying a hardware clock\n  \\ingroup hardware_clocks\n/\n/// \\tag::clkenum[]"]
pub type clock_index = ::core::ffi::c_uint;
#[doc = " \\tag::clock_hw[]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clock_hw_t {
    pub ctrl: io_rw_32,
    pub div: io_rw_32,
    pub selected: io_ro_32,
}
#[doc = " \\end::clock_hw[]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clock_resus_hw_t {
    pub ctrl: io_rw_32,
    pub status: io_ro_32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fc_hw_t {
    pub ref_khz: io_rw_32,
    pub min_khz: io_rw_32,
    pub max_khz: io_rw_32,
    pub delay: io_rw_32,
    pub interval: io_rw_32,
    pub src: io_rw_32,
    pub status: io_ro_32,
    pub result: io_ro_32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clocks_hw_t {
    pub clk: [clock_hw_t; 10usize],
    pub resus: clock_resus_hw_t,
    pub fc0: fc_hw_t,
    pub wake_en0: io_rw_32,
    pub wake_en1: io_rw_32,
    pub sleep_en0: io_rw_32,
    pub sleep_en1: io_rw_32,
    pub enabled0: io_ro_32,
    pub enabled1: io_ro_32,
    pub intr: io_ro_32,
    pub inte: io_rw_32,
    pub intf: io_rw_32,
    pub ints: io_ro_32,
}
extern "C" {
    #[doc = " \\brief Initialise the clock hardware\n  \\ingroup hardware_clocks\n\n  Must be called before any other clock function."]
    pub fn clocks_init();
}
extern "C" {
    #[doc = " \\brief Configure the specified clock\n  \\ingroup hardware_clocks\n\n See the tables in the description for details on the possible values for clock sources.\n\n \\param clk_index The clock to configure\n \\param src The main clock source, can be 0.\n \\param auxsrc The auxiliary clock source, which depends on which clock is being set. Can be 0\n \\param src_freq Frequency of the input clock source\n \\param freq Requested frequency"]
    pub fn clock_configure(
        clk_index: clock_index,
        src: u32,
        auxsrc: u32,
        src_freq: u32,
        freq: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Stop the specified clock\n  \\ingroup hardware_clocks\n\n \\param clk_index The clock to stop"]
    pub fn clock_stop(clk_index: clock_index);
}
extern "C" {
    #[doc = " \\brief Get the current frequency of the specified clock\n  \\ingroup hardware_clocks\n\n \\param clk_index Clock\n \\return Clock frequency in Hz"]
    pub fn clock_get_hz(clk_index: clock_index) -> u32;
}
extern "C" {
    #[doc = " \\brief Measure a clocks frequency using the Frequency counter.\n  \\ingroup hardware_clocks\n\n Uses the inbuilt frequency counter to measure the specified clocks frequency.\n Currently, this function is accurate to +-1KHz. See the datasheet for more details."]
    pub fn frequency_count_khz(src: uint) -> u32;
}
extern "C" {
    #[doc = " \\brief Set the \"current frequency\" of the clock as reported by clock_get_hz without actually changing the clock\n  \\ingroup hardware_clocks\n\n \\see clock_get_hz()"]
    pub fn clock_set_reported_hz(clk_index: clock_index, hz: uint);
}
#[doc = " \\brief Resus callback function type.\n  \\ingroup hardware_clocks\n\n User provided callback for a resus event (when clk_sys is stopped by the programmer and is restarted for them)."]
pub type resus_callback_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " \\brief Enable the resus function. Restarts clk_sys if it is accidentally stopped.\n  \\ingroup hardware_clocks\n\n The resuscitate function will restart the system clock if it falls below a certain speed (or stops). This\n could happen if the clock source the system clock is running from stops. For example if a PLL is stopped.\n\n \\param resus_callback a function pointer provided by the user to call if a resus event happens."]
    pub fn clocks_enable_resus(resus_callback: resus_callback_t);
}
extern "C" {
    #[doc = " \\brief Output an optionally divided clock to the specified gpio pin.\n  \\ingroup hardware_clocks\n\n \\param gpio The GPIO pin to output the clock to. Valid GPIOs are: 21, 23, 24, 25. These GPIOs are connected to the GPOUT0-3 clock generators.\n \\param src  The source clock. See the register field CLOCKS_CLK_GPOUT0_CTRL_AUXSRC for a full list. The list is the same for each GPOUT clock generator.\n \\param div_int  The integer part of the value to divide the source clock by. This is useful to not overwhelm the GPIO pin with a fast clock. this is in range of 1..2^24-1.\n \\param div_frac The fractional part of the value to divide the source clock by. This is in range of 0..255 (/256)."]
    pub fn clock_gpio_init_int_frac(gpio: uint, src: uint, div_int: u32, div_frac: u8);
}
extern "C" {
    #[doc = " \\brief Configure a clock to come from a gpio input\n  \\ingroup hardware_clocks\n\n \\param clk_index The clock to configure\n \\param gpio The GPIO pin to run the clock from. Valid GPIOs are: 20 and 22.\n \\param src_freq Frequency of the input clock source\n \\param freq Requested frequency"]
    pub fn clock_configure_gpin(
        clk_index: clock_index,
        gpio: uint,
        src_freq: u32,
        freq: u32,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dma_channel_hw_t {
    pub read_addr: io_rw_32,
    pub write_addr: io_rw_32,
    pub transfer_count: io_rw_32,
    pub ctrl_trig: io_rw_32,
    pub al1_ctrl: io_rw_32,
    pub al1_read_addr: io_rw_32,
    pub al1_write_addr: io_rw_32,
    pub al1_transfer_count_trig: io_rw_32,
    pub al2_ctrl: io_rw_32,
    pub al2_transfer_count: io_rw_32,
    pub al2_read_addr: io_rw_32,
    pub al2_write_addr_trig: io_rw_32,
    pub al3_ctrl: io_rw_32,
    pub al3_write_addr: io_rw_32,
    pub al3_transfer_count: io_rw_32,
    pub al3_read_addr_trig: io_rw_32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dma_hw_t {
    pub ch: [dma_channel_hw_t; 12usize],
    pub _pad0: [u32; 64usize],
    pub intr: io_rw_32,
    pub inte0: io_rw_32,
    pub intf0: io_rw_32,
    pub ints0: io_rw_32,
    pub _pad1: u32,
    pub inte1: io_rw_32,
    pub intf1: io_rw_32,
    pub ints1: io_rw_32,
    pub timer: [io_rw_32; 4usize],
    pub multi_channel_trigger: io_rw_32,
    pub sniff_ctrl: io_rw_32,
    pub sniff_data: io_rw_32,
    pub _pad2: u32,
    pub fifo_levels: io_ro_32,
    pub abort: io_rw_32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dma_debug_hw_t {
    pub ch: [dma_debug_hw_t_dma_debug_hw_channel; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dma_debug_hw_t_dma_debug_hw_channel {
    pub ctrdeq: io_rw_32,
    pub tcr: io_ro_32,
    pub pad: [u32; 14usize],
}
extern "C" {
    #[doc = " \\brief Mark a dma channel as used\n  \\ingroup hardware_dma\n\n Method for cooperative claiming of hardware. Will cause a panic if the channel\n is already claimed. Use of this method by libraries detects accidental\n configurations that would fail in unpredictable ways.\n\n \\param channel the dma channel"]
    pub fn dma_channel_claim(channel: uint);
}
extern "C" {
    #[doc = " \\brief Mark multiple dma channels as used\n  \\ingroup hardware_dma\n\n Method for cooperative claiming of hardware. Will cause a panic if any of the channels\n are already claimed. Use of this method by libraries detects accidental\n configurations that would fail in unpredictable ways.\n\n \\param channel_mask Bitfield of all required channels to claim (bit 0 == channel 0, bit 1 == channel 1 etc)"]
    pub fn dma_claim_mask(channel_mask: u32);
}
extern "C" {
    #[doc = " \\brief Mark a dma channel as no longer used\n  \\ingroup hardware_dma\n\n \\param channel the dma channel to release"]
    pub fn dma_channel_unclaim(channel: uint);
}
extern "C" {
    #[doc = " \\brief Mark multiple dma channels as no longer used\n  \\ingroup hardware_dma\n\n \\param channel_mask Bitfield of all channels to unclaim (bit 0 == channel 0, bit 1 == channel 1 etc)"]
    pub fn dma_unclaim_mask(channel_mask: u32);
}
extern "C" {
    #[doc = " \\brief Claim a free dma channel\n  \\ingroup hardware_dma\n\n \\param required if true the function will panic if none are available\n \\return the dma channel number or -1 if required was false, and none were free"]
    pub fn dma_claim_unused_channel(required: bool) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief Determine if a dma channel is claimed\n  \\ingroup hardware_dma\n\n \\param channel the dma channel\n \\return true if the channel is claimed, false otherwise\n \\see dma_channel_claim\n \\see dma_channel_claim_mask"]
    pub fn dma_channel_is_claimed(channel: uint) -> bool;
}
#[doc = "< Byte transfer (8 bits)"]
pub const DMA_SIZE_8: dma_channel_transfer_size = 0;
#[doc = "< Half word transfer (16 bits)"]
pub const DMA_SIZE_16: dma_channel_transfer_size = 1;
#[doc = "< Word transfer (32 bits)"]
pub const DMA_SIZE_32: dma_channel_transfer_size = 2;
#[doc = " \\brief Enumeration of available DMA channel transfer sizes.\n  \\ingroup hardware_dma\n\n Names indicate the number of bits."]
pub type dma_channel_transfer_size = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dma_channel_config {
    pub ctrl: u32,
}
extern "C" {
    #[doc = " \\brief Mark a dma timer as used\n  \\ingroup hardware_dma\n\n Method for cooperative claiming of hardware. Will cause a panic if the timer\n is already claimed. Use of this method by libraries detects accidental\n configurations that would fail in unpredictable ways.\n\n \\param timer the dma timer"]
    pub fn dma_timer_claim(timer: uint);
}
extern "C" {
    #[doc = " \\brief Mark a dma timer as no longer used\n  \\ingroup hardware_dma\n\n Method for cooperative claiming of hardware.\n\n \\param timer the dma timer to release"]
    pub fn dma_timer_unclaim(timer: uint);
}
extern "C" {
    #[doc = " \\brief Claim a free dma timer\n  \\ingroup hardware_dma\n\n \\param required if true the function will panic if none are available\n \\return the dma timer number or -1 if required was false, and none were free"]
    pub fn dma_claim_unused_timer(required: bool) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief Determine if a dma timer is claimed\n  \\ingroup hardware_dma\n\n \\param timer the dma timer\n \\return true if the timer is claimed, false otherwise\n \\see dma_timer_claim"]
    pub fn dma_timer_is_claimed(timer: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Performs DMA channel cleanup after use\n  \\ingroup hardware_dma\n\n This can be used to cleanup dma channels when they're no longer needed, such that they are in a clean state for reuse.\n IRQ's for the channel are disabled, any in flight-transfer is aborted and any outstanding interrupts are cleared.\n The channel is then clear to be reused for other purposes.\n\n \\code\n if (dma_channel >= 0) {\n     dma_channel_cleanup(dma_channel);\n     dma_channel_unclaim(dma_channel);\n     dma_channel = -1;\n }\n \\endcode\n\n \\param channel DMA channel"]
    pub fn dma_channel_cleanup(channel: uint);
}
extern "C" {
    pub fn print_dma_ctrl(channel: *mut dma_channel_hw_t);
}
#[doc = " \\brief Interpolator configuration\n  \\defgroup interp_config interp_config\n  \\ingroup hardware_interp\n\n Each interpolator needs to be configured, these functions provide handy helpers to set up configuration\n structures.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct interp_config {
    pub ctrl: u32,
}
extern "C" {
    #[doc = " \\brief Claim the interpolator lane specified\n  \\ingroup hardware_interp\n\n Use this function to claim exclusive access to the specified interpolator lane.\n\n This function will panic if the lane is already claimed.\n\n \\param interp Interpolator on which to claim a lane. interp0 or interp1\n \\param lane The lane number, 0 or 1."]
    pub fn interp_claim_lane(interp: *mut interp_hw_t, lane: uint);
}
extern "C" {
    #[doc = " \\brief Claim the interpolator lanes specified in the mask\n  \\ingroup hardware_interp\n\n \\param interp Interpolator on which to claim lanes. interp0 or interp1\n \\param lane_mask Bit pattern of lanes to claim (only bits 0 and 1 are valid)"]
    pub fn interp_claim_lane_mask(interp: *mut interp_hw_t, lane_mask: uint);
}
extern "C" {
    #[doc = " \\brief Release a previously claimed interpolator lane\n  \\ingroup hardware_interp\n\n \\param interp Interpolator on which to release a lane. interp0 or interp1\n \\param lane The lane number, 0 or 1"]
    pub fn interp_unclaim_lane(interp: *mut interp_hw_t, lane: uint);
}
extern "C" {
    #[doc = " \\brief Determine if an interpolator lane is claimed\n  \\ingroup hardware_interp\n\n \\param interp Interpolator whose lane to check\n \\param lane The lane number, 0 or 1\n \\return true if claimed, false otherwise\n \\see interp_claim_lane\n \\see interp_claim_lane_mask"]
    pub fn interp_lane_is_claimed(interp: *mut interp_hw_t, lane: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Release previously claimed interpolator lanes \\see interp_claim_lane_mask\n  \\ingroup hardware_interp\n\n \\param interp Interpolator on which to release lanes. interp0 or interp1\n \\param lane_mask Bit pattern of lanes to unclaim (only bits 0 and 1 are valid)"]
    pub fn interp_unclaim_lane_mask(interp: *mut interp_hw_t, lane_mask: uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct interp_hw_save_t {
    pub accum: [u32; 2usize],
    pub base: [u32; 3usize],
    pub ctrl: [u32; 2usize],
}
extern "C" {
    #[doc = " \\brief Save the specified interpolator state\n  \\ingroup hardware_interp\n\n Can be used to save state if you need an interpolator for another purpose, state\n can then be recovered afterwards and continue from that point\n\n \\param interp Interpolator instance, interp0 or interp1.\n \\param saver Pointer to the save structure to fill in"]
    pub fn interp_save(interp: *mut interp_hw_t, saver: *mut interp_hw_save_t);
}
extern "C" {
    #[doc = " \\brief Restore an interpolator state\n  \\ingroup hardware_interp\n\n \\param interp Interpolator instance, interp0 or interp1.\n \\param saver Pointer to save structure to reapply to the specified interpolator"]
    pub fn interp_restore(interp: *mut interp_hw_t, saver: *mut interp_hw_save_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pio_sm_hw {
    pub clkdiv: io_rw_32,
    pub execctrl: io_rw_32,
    pub shiftctrl: io_rw_32,
    pub addr: io_ro_32,
    pub instr: io_rw_32,
    pub pinctrl: io_rw_32,
}
pub type pio_sm_hw_t = pio_sm_hw;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pio_hw_t {
    pub ctrl: io_rw_32,
    pub fstat: io_ro_32,
    pub fdebug: io_rw_32,
    pub flevel: io_ro_32,
    pub txf: [io_wo_32; 4usize],
    pub rxf: [io_ro_32; 4usize],
    pub irq: io_rw_32,
    pub irq_force: io_wo_32,
    pub input_sync_bypass: io_rw_32,
    pub dbg_padout: io_ro_32,
    pub dbg_padoe: io_ro_32,
    pub dbg_cfginfo: io_ro_32,
    pub instr_mem: [io_wo_32; 32usize],
    pub sm: [pio_sm_hw_t; 4usize],
    pub intr: io_ro_32,
    pub inte0: io_rw_32,
    pub intf0: io_rw_32,
    pub ints0: io_ro_32,
    pub inte1: io_rw_32,
    pub intf1: io_rw_32,
    pub ints1: io_ro_32,
}
pub const pio_instr_bits_jmp: pio_instr_bits = 0;
pub const pio_instr_bits_wait: pio_instr_bits = 8192;
pub const pio_instr_bits_in: pio_instr_bits = 16384;
pub const pio_instr_bits_out: pio_instr_bits = 24576;
pub const pio_instr_bits_push: pio_instr_bits = 32768;
pub const pio_instr_bits_pull: pio_instr_bits = 32896;
pub const pio_instr_bits_mov: pio_instr_bits = 40960;
pub const pio_instr_bits_irq: pio_instr_bits = 49152;
pub const pio_instr_bits_set: pio_instr_bits = 57344;
pub type pio_instr_bits = ::core::ffi::c_uint;
pub const pio_pins: pio_src_dest = 0;
pub const pio_x: pio_src_dest = 1;
pub const pio_y: pio_src_dest = 2;
pub const pio_null: pio_src_dest = 163;
pub const pio_pindirs: pio_src_dest = 204;
pub const pio_exec_mov: pio_src_dest = 124;
pub const pio_status: pio_src_dest = 189;
pub const pio_pc: pio_src_dest = 109;
pub const pio_isr: pio_src_dest = 38;
pub const pio_osr: pio_src_dest = 55;
pub const pio_exec_out: pio_src_dest = 239;
#[doc = " \\brief Enumeration of values to pass for source/destination args for instruction encoding functions\n  \\ingroup pio_instructions\n\n \\note Not all values are suitable for all functions. Validity is only checked in debug mode when\n `PARAM_ASSERTIONS_ENABLED_PIO_INSTRUCTIONS` is 1"]
pub type pio_src_dest = ::core::ffi::c_uint;
pub const PIO_FIFO_JOIN_NONE: pio_fifo_join = 0;
pub const PIO_FIFO_JOIN_TX: pio_fifo_join = 1;
pub const PIO_FIFO_JOIN_RX: pio_fifo_join = 2;
#[doc = " \\brief FIFO join states\n  \\ingroup hardware_pio"]
pub type pio_fifo_join = ::core::ffi::c_uint;
pub const STATUS_TX_LESSTHAN: pio_mov_status_type = 0;
pub const STATUS_RX_LESSTHAN: pio_mov_status_type = 1;
#[doc = " \\brief MOV status types\n  \\ingroup hardware_pio"]
pub type pio_mov_status_type = ::core::ffi::c_uint;
pub type PIO = *mut pio_hw_t;
#[doc = " \\brief PIO Configuration structure\n  \\ingroup sm_config\n\n This structure is an in-memory representation of the configuration that can be applied to a PIO\n state machine later using pio_sm_set_config() or pio_sm_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pio_sm_config {
    pub clkdiv: u32,
    pub execctrl: u32,
    pub shiftctrl: u32,
    pub pinctrl: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pio_program {
    pub instructions: *const u16,
    pub length: u8,
    pub origin: i8,
}
pub type pio_program_t = pio_program;
extern "C" {
    #[doc = " \\brief Determine whether the given program can (at the time of the call) be loaded onto the PIO instance\n  \\ingroup hardware_pio\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param program the program definition\n \\return true if the program can be loaded; false if there is not suitable space in the instruction memory"]
    pub fn pio_can_add_program(pio: PIO, program: *const pio_program_t) -> bool;
}
extern "C" {
    #[doc = " \\brief Determine whether the given program can (at the time of the call) be loaded onto the PIO instance starting at a particular location\n  \\ingroup hardware_pio\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param program the program definition\n \\param offset the instruction memory offset wanted for the start of the program\n \\return true if the program can be loaded at that location; false if there is not space in the instruction memory"]
    pub fn pio_can_add_program_at_offset(
        pio: PIO,
        program: *const pio_program_t,
        offset: uint,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Attempt to load the program, panicking if not possible\n  \\ingroup hardware_pio\n\n \\see pio_can_add_program() if you need to check whether the program can be loaded\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param program the program definition\n \\return the instruction memory offset the program is loaded at"]
    pub fn pio_add_program(pio: PIO, program: *const pio_program_t) -> uint;
}
extern "C" {
    #[doc = " \\brief Attempt to load the program at the specified instruction memory offset, panicking if not possible\n  \\ingroup hardware_pio\n\n \\see pio_can_add_program_at_offset() if you need to check whether the program can be loaded\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param program the program definition\n \\param offset the instruction memory offset wanted for the start of the program"]
    pub fn pio_add_program_at_offset(pio: PIO, program: *const pio_program_t, offset: uint);
}
extern "C" {
    #[doc = " \\brief Remove a program from a PIO instance's instruction memory\n  \\ingroup hardware_pio\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param program the program definition\n \\param loaded_offset the loaded offset returned when the program was added"]
    pub fn pio_remove_program(pio: PIO, program: *const pio_program_t, loaded_offset: uint);
}
extern "C" {
    #[doc = " \\brief Clears all of a PIO instance's instruction memory\n  \\ingroup hardware_pio\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1"]
    pub fn pio_clear_instruction_memory(pio: PIO);
}
extern "C" {
    #[doc = " \\brief Resets the state machine to a consistent state, and configures it\n  \\ingroup hardware_pio\n\n This method:\n - Disables the state machine (if running)\n - Clears the FIFOs\n - Applies the configuration specified by 'config'\n - Resets any internal state e.g. shift counters\n - Jumps to the initial program location given by 'initial_pc'\n\n The state machine is left disabled on return from this call.\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param sm State machine index (0..3)\n \\param initial_pc the initial program memory offset to run from\n \\param config the configuration to apply (or NULL to apply defaults)"]
    pub fn pio_sm_init(pio: PIO, sm: uint, initial_pc: uint, config: *const pio_sm_config);
}
pub const pis_interrupt0: pio_interrupt_source = 8;
pub const pis_interrupt1: pio_interrupt_source = 9;
pub const pis_interrupt2: pio_interrupt_source = 10;
pub const pis_interrupt3: pio_interrupt_source = 11;
pub const pis_sm0_tx_fifo_not_full: pio_interrupt_source = 4;
pub const pis_sm1_tx_fifo_not_full: pio_interrupt_source = 5;
pub const pis_sm2_tx_fifo_not_full: pio_interrupt_source = 6;
pub const pis_sm3_tx_fifo_not_full: pio_interrupt_source = 7;
pub const pis_sm0_rx_fifo_not_empty: pio_interrupt_source = 0;
pub const pis_sm1_rx_fifo_not_empty: pio_interrupt_source = 1;
pub const pis_sm2_rx_fifo_not_empty: pio_interrupt_source = 2;
pub const pis_sm3_rx_fifo_not_empty: pio_interrupt_source = 3;
#[doc = " \\brief PIO interrupt source numbers for pio related IRQs\n \\ingroup hardware_pio"]
pub type pio_interrupt_source = ::core::ffi::c_uint;
extern "C" {
    #[doc = " \\brief Empty out a state machine's TX FIFO\n  \\ingroup hardware_pio\n\n This method executes `pull` instructions on the state machine until the TX\n FIFO is empty. This disturbs the contents of the OSR, so see also\n pio_sm_clear_fifos() which clears both FIFOs but leaves the state machine's\n internal state undisturbed.\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param sm State machine index (0..3)\n\n \\sa pio_sm_clear_fifos()"]
    pub fn pio_sm_drain_tx_fifo(pio: PIO, sm: uint);
}
extern "C" {
    #[doc = " \\brief Use a state machine to set a value on all pins for the PIO instance\n  \\ingroup hardware_pio\n\n This method repeatedly reconfigures the target state machine's pin configuration and executes 'set' instructions to set values on all 32 pins,\n before restoring the state machine's pin configuration to what it was.\n\n This method is provided as a convenience to set initial pin states, and should not be used against a state machine that is enabled.\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param sm State machine index (0..3) to use\n \\param pin_values the pin values to set"]
    pub fn pio_sm_set_pins(pio: PIO, sm: uint, pin_values: u32);
}
extern "C" {
    #[doc = " \\brief Use a state machine to set a value on multiple pins for the PIO instance\n  \\ingroup hardware_pio\n\n This method repeatedly reconfigures the target state machine's pin configuration and executes 'set' instructions to set values on up to 32 pins,\n before restoring the state machine's pin configuration to what it was.\n\n This method is provided as a convenience to set initial pin states, and should not be used against a state machine that is enabled.\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param sm State machine index (0..3) to use\n \\param pin_values the pin values to set (if the corresponding bit in pin_mask is set)\n \\param pin_mask a bit for each pin to indicate whether the corresponding pin_value for that pin should be applied."]
    pub fn pio_sm_set_pins_with_mask(pio: PIO, sm: uint, pin_values: u32, pin_mask: u32);
}
extern "C" {
    #[doc = " \\brief Use a state machine to set the pin directions for multiple pins for the PIO instance\n  \\ingroup hardware_pio\n\n This method repeatedly reconfigures the target state machine's pin configuration and executes 'set' instructions to set pin directions on up to 32 pins,\n before restoring the state machine's pin configuration to what it was.\n\n This method is provided as a convenience to set initial pin directions, and should not be used against a state machine that is enabled.\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param sm State machine index (0..3) to use\n \\param pin_dirs the pin directions to set - 1 = out, 0 = in (if the corresponding bit in pin_mask is set)\n \\param pin_mask a bit for each pin to indicate whether the corresponding pin_value for that pin should be applied."]
    pub fn pio_sm_set_pindirs_with_mask(pio: PIO, sm: uint, pin_dirs: u32, pin_mask: u32);
}
extern "C" {
    #[doc = " \\brief Use a state machine to set the same pin direction for multiple consecutive pins for the PIO instance\n  \\ingroup hardware_pio\n\n This method repeatedly reconfigures the target state machine's pin configuration and executes 'set' instructions to set the pin direction on consecutive pins,\n before restoring the state machine's pin configuration to what it was.\n\n This method is provided as a convenience to set initial pin directions, and should not be used against a state machine that is enabled.\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param sm State machine index (0..3) to use\n \\param pin_base the first pin to set a direction for\n \\param pin_count the count of consecutive pins to set the direction for\n \\param is_out the direction to set; true = out, false = in"]
    pub fn pio_sm_set_consecutive_pindirs(
        pio: PIO,
        sm: uint,
        pin_base: uint,
        pin_count: uint,
        is_out: bool,
    );
}
extern "C" {
    #[doc = " \\brief Mark a state machine as used\n  \\ingroup hardware_pio\n\n Method for cooperative claiming of hardware. Will cause a panic if the state machine\n is already claimed. Use of this method by libraries detects accidental\n configurations that would fail in unpredictable ways.\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param sm State machine index (0..3)"]
    pub fn pio_sm_claim(pio: PIO, sm: uint);
}
extern "C" {
    #[doc = " \\brief Mark multiple state machines as used\n  \\ingroup hardware_pio\n\n Method for cooperative claiming of hardware. Will cause a panic if any of the state machines\n are already claimed. Use of this method by libraries detects accidental\n configurations that would fail in unpredictable ways.\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param sm_mask Mask of state machine indexes"]
    pub fn pio_claim_sm_mask(pio: PIO, sm_mask: uint);
}
extern "C" {
    #[doc = " \\brief Mark a state machine as no longer used\n  \\ingroup hardware_pio\n\n Method for cooperative claiming of hardware.\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param sm State machine index (0..3)"]
    pub fn pio_sm_unclaim(pio: PIO, sm: uint);
}
extern "C" {
    #[doc = " \\brief Claim a free state machine on a PIO instance\n  \\ingroup hardware_pio\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param required if true the function will panic if none are available\n \\return the state machine index or -1 if required was false, and none were free"]
    pub fn pio_claim_unused_sm(pio: PIO, required: bool) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief Determine if a PIO state machine is claimed\n  \\ingroup hardware_pio\n\n \\param pio The PIO instance; either \\ref pio0 or \\ref pio1\n \\param sm State machine index (0..3)\n \\return true if claimed, false otherwise\n \\see pio_sm_claim\n \\see pio_claim_sm_mask"]
    pub fn pio_sm_is_claimed(pio: PIO, sm: uint) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pwm_slice_hw {
    pub csr: io_rw_32,
    pub div: io_rw_32,
    pub ctr: io_rw_32,
    pub cc: io_rw_32,
    pub top: io_rw_32,
}
pub type pwm_slice_hw_t = pwm_slice_hw;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pwm_hw_t {
    pub slice: [pwm_slice_hw_t; 8usize],
    pub en: io_rw_32,
    pub intr: io_rw_32,
    pub inte: io_rw_32,
    pub intf: io_rw_32,
    pub ints: io_ro_32,
}
#[doc = "< Free-running counting at rate dictated by fractional divider"]
pub const PWM_DIV_FREE_RUNNING: pwm_clkdiv_mode = 0;
#[doc = "< Fractional divider is gated by the PWM B pin"]
pub const PWM_DIV_B_HIGH: pwm_clkdiv_mode = 1;
#[doc = "< Fractional divider advances with each rising edge of the PWM B pin"]
pub const PWM_DIV_B_RISING: pwm_clkdiv_mode = 2;
#[doc = "< Fractional divider advances with each falling edge of the PWM B pin"]
pub const PWM_DIV_B_FALLING: pwm_clkdiv_mode = 3;
#[doc = " \\brief PWM Divider mode settings\n   \\ingroup hardware_pwm\n"]
pub type pwm_clkdiv_mode = ::core::ffi::c_uint;
pub const PWM_CHAN_A: pwm_chan = 0;
pub const PWM_CHAN_B: pwm_chan = 1;
pub type pwm_chan = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pwm_config {
    pub csr: u32,
    pub div: u32,
    pub top: u32,
}
#[doc = " \\tag::resets_hw[]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct resets_hw_t {
    pub reset: io_rw_32,
    pub wdsel: io_rw_32,
    pub reset_done: io_ro_32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtc_hw_t {
    pub clkdiv_m1: io_rw_32,
    pub setup_0: io_rw_32,
    pub setup_1: io_rw_32,
    pub ctrl: io_rw_32,
    pub irq_setup_0: io_rw_32,
    pub irq_setup_1: io_rw_32,
    pub rtc_1: io_ro_32,
    pub rtc_0: io_ro_32,
    pub intr: io_ro_32,
    pub inte: io_rw_32,
    pub intf: io_rw_32,
    pub ints: io_ro_32,
}
#[doc = " Callback function type for RTC alarms\n  \\ingroup hardware_rtc\n\n \\sa rtc_set_alarm()"]
pub type rtc_callback_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " \\brief Initialise the RTC system\n  \\ingroup hardware_rtc"]
    pub fn rtc_init();
}
extern "C" {
    #[doc = " \\brief Set the RTC to the specified time\n  \\ingroup hardware_rtc\n\n \\note Note that after setting the RTC date and time, a subsequent read of the values (e.g. via rtc_get_datetime()) may not\n reflect the new setting until up to three cycles of the potentially-much-slower RTC clock domain have passed. This represents a period\n of 64 microseconds with the default RTC clock configuration.\n\n \\param t Pointer to a \\ref datetime_t structure contains time to set\n \\return true if set, false if the passed in datetime was invalid."]
    pub fn rtc_set_datetime(t: *mut datetime_t) -> bool;
}
extern "C" {
    #[doc = " \\brief Get the current time from the RTC\n  \\ingroup hardware_rtc\n\n \\param t Pointer to a \\ref datetime_t structure to receive the current RTC time\n \\return true if datetime is valid, false if the RTC is not running."]
    pub fn rtc_get_datetime(t: *mut datetime_t) -> bool;
}
extern "C" {
    #[doc = " \\brief Is the RTC running?\n  \\ingroup hardware_rtc\n"]
    pub fn rtc_running() -> bool;
}
extern "C" {
    #[doc = " \\brief Set a time in the future for the RTC to call a user provided callback\n  \\ingroup hardware_rtc\n\n  \\param t Pointer to a \\ref datetime_t structure containing a time in the future to fire the alarm. Any values set to -1 will not be matched on.\n  \\param user_callback pointer to a \\ref rtc_callback_t to call when the alarm fires"]
    pub fn rtc_set_alarm(t: *mut datetime_t, user_callback: rtc_callback_t);
}
extern "C" {
    #[doc = " \\brief Enable the RTC alarm (if inactive)\n  \\ingroup hardware_rtc"]
    pub fn rtc_enable_alarm();
}
extern "C" {
    #[doc = " \\brief Disable the RTC alarm (if active)\n  \\ingroup hardware_rtc"]
    pub fn rtc_disable_alarm();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vreg_and_chip_reset_hw_t {
    pub vreg: io_rw_32,
    pub bod: io_rw_32,
    pub chip_reset: io_rw_32,
}
#[doc = "< 0.85v"]
pub const VREG_VOLTAGE_0_85: vreg_voltage = 6;
#[doc = "< 0.90v"]
pub const VREG_VOLTAGE_0_90: vreg_voltage = 7;
#[doc = "< 0.95v"]
pub const VREG_VOLTAGE_0_95: vreg_voltage = 8;
#[doc = "< 1.00v"]
pub const VREG_VOLTAGE_1_00: vreg_voltage = 9;
#[doc = "< 1.05v"]
pub const VREG_VOLTAGE_1_05: vreg_voltage = 10;
#[doc = "< 1.10v"]
pub const VREG_VOLTAGE_1_10: vreg_voltage = 11;
#[doc = "< 1.15v"]
pub const VREG_VOLTAGE_1_15: vreg_voltage = 12;
#[doc = "< 1.20v"]
pub const VREG_VOLTAGE_1_20: vreg_voltage = 13;
#[doc = "< 1.25v"]
pub const VREG_VOLTAGE_1_25: vreg_voltage = 14;
#[doc = "< 1.30v"]
pub const VREG_VOLTAGE_1_30: vreg_voltage = 15;
#[doc = "< Always the minimum possible voltage"]
pub const VREG_VOLTAGE_MIN: vreg_voltage = 6;
#[doc = "< Default voltage on power up."]
pub const VREG_VOLTAGE_DEFAULT: vreg_voltage = 11;
#[doc = "< Always the maximum possible voltage"]
pub const VREG_VOLTAGE_MAX: vreg_voltage = 15;
#[doc = " Possible voltage values that can be applied to the regulator"]
pub type vreg_voltage = ::core::ffi::c_uint;
extern "C" {
    #[doc = " \\brief  Set voltage\n  \\ingroup hardware_vreg\n\n \\param voltage  The voltage (from enumeration \\ref vreg_voltage) to apply to the voltage regulator"]
    pub fn vreg_set_voltage(voltage: vreg_voltage);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct watchdog_hw_t {
    pub ctrl: io_rw_32,
    pub load: io_wo_32,
    pub reason: io_ro_32,
    pub scratch: [io_rw_32; 8usize],
    pub tick: io_rw_32,
}
extern "C" {
    #[doc = " \\brief Define actions to perform at watchdog timeout\n  \\ingroup hardware_watchdog\n\n \\note If \\ref watchdog_start_tick value does not give a 1MHz clock to the watchdog system, then the \\p delay_ms\n parameter will not be in microseconds. See the datasheet for more details.\n\n By default the SDK assumes a 12MHz XOSC and sets the \\ref watchdog_start_tick appropriately.\n\n \\param pc If Zero, a standard boot will be performed, if non-zero this is the program counter to jump to on reset.\n \\param sp If \\p pc is non-zero, this will be the stack pointer used.\n \\param delay_ms Initial load value. Maximum value 0x7fffff, approximately 8.3s."]
    pub fn watchdog_reboot(pc: u32, sp: u32, delay_ms: u32);
}
extern "C" {
    #[doc = " \\brief Start the watchdog tick\n  \\ingroup hardware_watchdog\n\n \\param cycles This needs to be a divider that when applied to the XOSC input, produces a 1MHz clock. So if the XOSC is\n 12MHz, this will need to be 12."]
    pub fn watchdog_start_tick(cycles: uint);
}
extern "C" {
    #[doc = " \\brief Reload the watchdog counter with the amount of time set in watchdog_enable\n  \\ingroup hardware_watchdog\n"]
    pub fn watchdog_update();
}
extern "C" {
    #[doc = " \\brief Enable the watchdog\n \\ingroup hardware_watchdog\n\n \\note If \\ref watchdog_start_tick value does not give a 1MHz clock to the watchdog system, then the \\p delay_ms\n parameter will not be in microseconds. See the datasheet for more details.\n\n By default the SDK assumes a 12MHz XOSC and sets the \\ref watchdog_start_tick appropriately.\n\n This method sets a marker in the watchdog scratch register 4 that is checked by \\ref watchdog_enable_caused_reboot.\n If the device is subsequently reset via a call to watchdog_reboot (including for example by dragging a UF2\n onto the RPI-RP2), then this value will be cleared, and so \\ref watchdog_enable_caused_reboot will\n return false.\n\n \\param delay_ms Number of milliseconds before watchdog will reboot without watchdog_update being called. Maximum of 0x7fffff, which is approximately 8.3 seconds\n \\param pause_on_debug If the watchdog should be paused when the debugger is stepping through code"]
    pub fn watchdog_enable(delay_ms: u32, pause_on_debug: bool);
}
extern "C" {
    #[doc = " \\brief Did the watchdog cause the last reboot?\n \\ingroup hardware_watchdog\n\n @return true If the watchdog timer or a watchdog force caused the last reboot\n @return false If there has been no watchdog reboot since the last power on reset. A power on reset is typically caused by a power cycle or the run pin (reset button) being toggled."]
    pub fn watchdog_caused_reboot() -> bool;
}
extern "C" {
    #[doc = " \\brief Did watchdog_enable cause the last reboot?\n \\ingroup hardware_watchdog\n\n Perform additional checking along with \\ref watchdog_caused_reboot to determine if a watchdog timeout initiated by\n \\ref watchdog_enable caused the last reboot.\n\n This method checks for a special value in watchdog scratch register 4 placed there by \\ref watchdog_enable.\n This would not be present if a watchdog reset is initiated by \\ref watchdog_reboot or by the RP2040 bootrom\n (e.g. dragging a UF2 onto the RPI-RP2 drive).\n\n @return true If the watchdog timer or a watchdog force caused (see \\ref watchdog_caused_reboot) the last reboot\n              and the watchdog reboot happened after \\ref watchdog_enable was called\n @return false If there has been no watchdog reboot since the last power on reset, or the watchdog reboot was not caused\n               by a watchdog timeout after \\ref watchdog_enable was called.\n               A power on reset is typically caused by a power cycle or the run pin (reset button) being toggled."]
    pub fn watchdog_enable_caused_reboot() -> bool;
}
extern "C" {
    #[doc = " @brief Returns the number of microseconds before the watchdog will reboot the chip.\n \\ingroup hardware_watchdog\n\n @return The number of microseconds before the watchdog will reboot the chip."]
    pub fn watchdog_get_count() -> u32;
}
